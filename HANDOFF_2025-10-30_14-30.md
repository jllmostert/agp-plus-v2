---
version: v3.1
phase: Phase 4 - Sensor Registration Debug
status: active
date: 2025-10-30
time: 14:30 CET
---

# HANDOFF — Sensor endTime Debug Session

## 🎯 Current Problem

**Symptom**: Sensors are added to IndexedDB with `startTime` only, `endTime` is always `null`

**Expected Behavior**:
- When gap detected at 2025-09-20 23:45 → 2025-09-21 12:30
- OLD sensor should get: `endTime = 2025-09-20 23:45` (last reading before gap)
- NEW sensor should get: `startTime = 2025-09-21 12:30` (first reading after gap), `endTime = null` (still active)

**Actual Behavior**:
- NEW sensor gets: `startTime = 2025-09-21 12:30`, `endTime = null` ✅
- OLD sensor NEVER gets updated with `endTime` ❌

**Impact**: Sensor history shows all sensors as "still active" with no duration

## 🔍 Where to Look

### Detection Engine Output
**File**: `src/core/sensorDetectionEngine.js`

The engine returns candidates like this:
```javascript
{
  timestamp: "2025-09-21T12:30:00.000Z",
  gaps: [{
    startTime: "2025-09-20T23:45:00.000Z",  // Last reading of OLD sensor
    endTime: "2025-09-21T12:30:00.000Z",    // First reading of NEW sensor
    duration: 765  // minutes
  }]
}
```

**The gap object HAS the data we need!**
- `gaps[0].startTime` = when the OLD sensor ended
- `gaps[0].endTime` = when the NEW sensor started

### Registration Handler
**File**: `src/components/SensorRegistration.jsx`

Current `handleConfirm` function (INCORRECT):
```javascript
const handleConfirm = async (candidate) => {
  await addSensor({
    start_timestamp: candidate.timestamp,  // ✅ NEW sensor start
    end_timestamp: null,                    // ❌ OLD sensor end NOT SET!
    // ...
  });
};
```

**What we need to add**:
```javascript
const handleConfirm = async (candidate) => {
  // 1. Get the most recent sensor (the one that just ended)
  const sensors = await getSensorHistory();
  const mostRecentSensor = sensors[sensors.length - 1];
  
  // 2. Update its endTime with the gap startTime
  if (mostRecentSensor && candidate.gaps.length > 0) {
    await updateSensor(mostRecentSensor.id, {
      end_timestamp: candidate.gaps[0].startTime  // Last reading before gap!
    });
  }
  
  // 3. Add the new sensor
  await addSensor({
    start_timestamp: candidate.gaps[0].endTime,  // First reading after gap
    end_timestamp: null,
    // ...
  });
};
```

## 🧪 Test Case

**Test CSV**: `test-data/SAMPLE__Jo Mostert 30-10-2025_7d.csv`

**Expected Detection**:
- Sensor #1 ended: Oct 25, 08:11 (gap starts here)
- Sensor #2 started: Oct 25, 12:30 (gap ends here)

**Expected IndexedDB After Confirm**:
```
Sensor #219 (existing):
  start_timestamp: "2025-09-15T10:00:00.000Z"
  end_timestamp: "2025-10-25T08:11:00.000Z"  ← Should be updated!
  
Sensor #220 (new):
  start_timestamp: "2025-10-25T12:30:00.000Z"
  end_timestamp: null
```

## 🔧 Files to Modify

1. **Check storage API**: `src/storage/sensorStorage.js`
   - Does `updateSensor(id, updates)` function exist?
   - If not, we need to create it

2. **Fix handler**: `src/components/SensorRegistration.jsx`
   - Update `handleConfirm` to set previous sensor's `endTime`
   - Use gap data from candidate object

## 📊 Current State

**Server**: http://localhost:3001/ (PID 31953)
**Branch**: main
**Last Commit**: 7aa4399 - Import fixes

**IndexedDB Status**:
- 219 sensors (March 2022 - Oct 2025)
- All have `end_timestamp: null` ❌
- Need to fix before adding more

## 🎯 Debug Steps

1. **Read storage API**:
   ```bash
   view /Users/jomostert/Documents/Projects/agp-plus/src/storage/sensorStorage.js
   ```

2. **Check if updateSensor exists**:
   - If YES: Use it in handleConfirm
   - If NO: Create it first

3. **Test the fix**:
   - Upload test CSV
   - Confirm ONE candidate
   - Check IndexedDB:
     - Sensor #219 should have endTime
     - Sensor #220 should have startTime + null endTime

4. **Verify duration calculation**:
   - If both sensors have proper timestamps
   - Duration should auto-calculate in UI

## 🚨 Critical Notes

- **Do NOT run confirm on all candidates yet** - test with ONE first
- **Check IndexedDB before and after** to verify the fix works
- **The gap object contains BOTH timestamps we need**:
  - `gap.startTime` → previous sensor's END
  - `gap.endTime` → new sensor's START

## 📝 Success Criteria

- [ ] updateSensor function exists in storage API
- [ ] handleConfirm updates previous sensor's endTime
- [ ] New sensor gets correct startTime from gap.endTime
- [ ] IndexedDB shows proper timestamps for both sensors
- [ ] Sensor history displays duration (not "active")

---

**Next Action**: Check sensorStorage.js for updateSensor function
**Focus**: Fix the endTime gap before proceeding with more registrations
**Status**: Investigation phase - don't commit yet!
