════════════════════════════════════════════════════════
AGP+ v2.1 - Complete Source Code Bundle
Generated: Wed Oct 22 17:20:24 CEST 2025
════════════════════════════════════════════════════════


┌────────────────────────────────────────────────────────┐
│ FILE: src/core/metrics-engine.js
└────────────────────────────────────────────────────────┘

/**
 * ARTIFACT-01: Metrics Engine
 * Pure calculation functions for glucose metrics
 * 
 * Exports:
 * - CONFIG: Configuration constants
 * - utils: Utility functions (parseDecimal, parseDate, formatDate, isInTimePeriod)
 * - calculateMetrics: Main metrics calculation
 * - calculateAGP: Ambulatory Glucose Profile percentiles
 * - detectEvents: Hypo/hyper event detection
 */

export const CONFIG = {
  GLUCOSE: {
    LOW: 70,
    HIGH: 180,
    CRITICAL_LOW: 54,
    CRITICAL_HIGH: 250,
    MAX: 400
  },
  AGP_BINS: 288,
  HYPO_MIN_DURATION: 15,
  HYPER_MIN_DURATION: 120,
  MODD_COVERAGE_THRESHOLD: 0.7,
  COMPARISON_DAYS: 14,
  CSV_SKIP_LINES: 6,
  TIME_SPLIT: {
    NIGHT_START: 0,
    NIGHT_END: 6,
    DAY_START: 6,
    DAY_END: 24
  }
};

export const utils = {
  parseDecimal: (str) => str && str !== '' ? parseFloat(str.replace(',', '.')) : NaN,
  
  parseDate: (dateStr, timeStr) => {
    // CRITICAL: Force Europe/Brussels timezone for consistent parsing
    // CareLink exports are in local time, must be interpreted consistently
    const [year, month, day] = dateStr.split('/');
    const [hours, minutes, seconds] = timeStr.split(':');
    
    // Create date string in ISO format for Brussels timezone
    const isoString = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}T${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds || 0).padStart(2, '0')}`;
    
    // Parse as Brussels time (this handles DST automatically)
    const date = new Date(isoString);
    
    return date;
  },
  
  formatDate: (date) => {
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = date.getFullYear();
    return `${day}-${month}-${year}`;
  },
  
  isInTimePeriod: (hour, period) => {
    if (period === 'night') {
      return hour >= CONFIG.TIME_SPLIT.NIGHT_START && hour < CONFIG.TIME_SPLIT.NIGHT_END;
    }
    if (period === 'day') {
      return hour >= CONFIG.TIME_SPLIT.DAY_START && hour < CONFIG.TIME_SPLIT.DAY_END;
    }
    return true;
  }
};

/**
 * Calculate glucose metrics for a given period
 * @param {Array} data - Array of glucose data objects {date, time, glucose}
 * @param {string} startDate - Start date in YYYY/MM/DD format
 * @param {string} endDate - End date in YYYY/MM/DD format
 * @param {Set} filterDates - Optional set of dates to include (for workday filtering)
 * @param {Object} timeFilter - Optional time filter {type: 'day_night', value: 'day'|'night'}
 * @returns {Object} Metrics object with TIR, CV, MAGE, MODD, etc.
 */
export const calculateMetrics = (data, startDate, endDate, filterDates = null, timeFilter = null) => {
  // Filter data by date range and optional filters
  const filtered = data.filter(row => {
    const dt = utils.parseDate(row.date, row.time);
    const startDt = utils.parseDate(startDate, '00:00:00');
    const endDt = utils.parseDate(endDate, '23:59:59');
    const inRange = dt >= startDt && dt <= endDt;
    
    if (filterDates && !filterDates.has(row.date)) return false;
    
    if (timeFilter && timeFilter.type === 'day_night') {
      const hour = dt.getHours();
      if (!utils.isInTimePeriod(hour, timeFilter.value)) return false;
    }
    
    return inRange;
  });

  if (filtered.length === 0) return null;

  // Basic statistics
  const values = filtered.map(r => r.glucose);
  const mean = values.reduce((a, b) => a + b, 0) / values.length;
  const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / (values.length - 1);
  const sd = Math.sqrt(variance);
  const cv = (sd / mean) * 100;
  const gmi = 3.31 + (0.02392 * mean);

  // Time in ranges
  const tir = (values.filter(v => v >= 70 && v <= 180).length / values.length) * 100;
  const tar = (values.filter(v => v > 180).length / values.length) * 100;
  const tbr = (values.filter(v => v < 70).length / values.length) * 100;

  // MAGE - Mean Amplitude of Glycemic Excursions
  const byDay = {};
  filtered.forEach(r => {
    if (!byDay[r.date]) byDay[r.date] = [];
    byDay[r.date].push({ t: utils.parseDate(r.date, r.time), g: r.glucose });
  });
  
  const dailyMAGE = [];
  Object.values(byDay).forEach(dayData => {
    const daySeries = dayData.sort((a, b) => a.t - b.t).map(x => x.g);
    if (daySeries.length < 3) return;
    
    // Find extrema (local minima and maxima)
    const dayExtrema = [];
    for (let i = 1; i < daySeries.length - 1; i++) {
      const prev = daySeries[i - 1];
      const curr = daySeries[i];
      const next = daySeries[i + 1];
      if ((curr > prev && curr > next) || (curr < prev && curr < next)) {
        dayExtrema.push({ value: curr, isPeak: curr > prev });
      }
    }
    
    // Calculate excursions between alternating peaks/troughs
    const dayExcursions = [];
    for (let k = 1; k < dayExtrema.length; k++) {
      const e1 = dayExtrema[k - 1];
      const e2 = dayExtrema[k];
      if (e1.isPeak === e2.isPeak) continue; // Skip same-type extrema
      const amp = Math.abs(e2.value - e1.value);
      if (amp >= sd - 1e-9) { // Only count excursions >= 1 SD
        dayExcursions.push(amp);
      }
    }
    
    if (dayExcursions.length > 0) {
      const dayMAGE = dayExcursions.reduce((sum, e) => sum + e, 0) / dayExcursions.length;
      dailyMAGE.push(dayMAGE);
    }
  });
  
  const mage = dailyMAGE.length > 0 
    ? dailyMAGE.reduce((sum, m) => sum + m, 0) / dailyMAGE.length 
    : 0;

  // MODD - Mean Of Daily Differences
  const MODD_BINS = CONFIG.AGP_BINS;
  const dayBins = new Map();
  
  const ensureDay = (date) => {
    if (!dayBins.has(date)) {
      dayBins.set(date, {
        sum: new Float64Array(MODD_BINS),
        count: new Uint16Array(MODD_BINS),
        filled: Array(MODD_BINS).fill(false)
      });
    }
    return dayBins.get(date);
  };
  
  // Bin glucose values by time of day
  filtered.forEach(row => {
    const dt = utils.parseDate(row.date, row.time);
    const minuteOfDay = dt.getHours() * 60 + dt.getMinutes();
    const binIdx = Math.floor(minuteOfDay / 5);
    if (binIdx < 0 || binIdx >= MODD_BINS) return;
    
    const dayData = ensureDay(row.date);
    dayData.sum[binIdx] += row.glucose;
    dayData.count[binIdx] += 1;
    dayData.filled[binIdx] = true;
  });
  
  // Check if a day has sufficient coverage
  const dayHasCoverage = (date) => {
    const dayData = dayBins.get(date);
    if (!dayData) return false;
    const filledCount = dayData.filled.reduce((sum, filled) => sum + (filled ? 1 : 0), 0);
    return filledCount >= Math.round(CONFIG.MODD_COVERAGE_THRESHOLD * MODD_BINS);
  };
  
  // Calculate MODD between consecutive days
  const sortedDates = Array.from(dayBins.keys()).sort();
  let moddSum = 0;
  let moddCount = 0;
  
  for (let d = 0; d < sortedDates.length - 1; d++) {
    const date1 = sortedDates[d];
    const date2 = sortedDates[d + 1];
    
    if (!dayHasCoverage(date1) || !dayHasCoverage(date2)) continue;
    
    const day1 = dayBins.get(date1);
    const day2 = dayBins.get(date2);
    
    for (let bin = 0; bin < MODD_BINS; bin++) {
      if (day1.count[bin] > 0 && day2.count[bin] > 0) {
        const val1 = day1.sum[bin] / day1.count[bin];
        const val2 = day2.sum[bin] / day2.count[bin];
        moddSum += Math.abs(val2 - val1);
        moddCount++;
      }
    }
  }
  
  const modd = moddCount > 0 ? moddSum / moddCount : 0;
  const uniqueDays = new Set(filtered.map(r => r.date)).size;

  return {
    mean: Math.round(mean),
    sd: sd.toFixed(1),
    cv: cv.toFixed(1),
    tir: tir.toFixed(1),
    tar: tar.toFixed(1),
    tbr: tbr.toFixed(1),
    gmi: gmi.toFixed(1),
    mage: mage.toFixed(1),
    modd: modd.toFixed(1),
    min: Math.min(...values),
    max: Math.max(...values),
    days: uniqueDays,
    readingCount: filtered.length
  };
};

/**
 * Calculate Ambulatory Glucose Profile (AGP) percentiles
 * @param {Array} data - Array of glucose data objects
 * @param {string} startDate - Start date in YYYY/MM/DD format
 * @param {string} endDate - End date in YYYY/MM/DD format
 * @returns {Array} Array of 288 objects with p5, p25, p50, p75, p95, mean
 */
export const calculateAGP = (data, startDate, endDate) => {
  const filtered = data.filter(row => {
    const dt = utils.parseDate(row.date, row.time);
    const startDt = utils.parseDate(startDate, '00:00:00');
    const endDt = utils.parseDate(endDate, '23:59:59');
    return dt >= startDt && dt <= endDt;
  });

  const bins = Array(CONFIG.AGP_BINS).fill(null).map(() => []);
  
  // Bin glucose values by time of day
  filtered.forEach(row => {
    const dt = utils.parseDate(row.date, row.time);
    const minuteOfDay = dt.getHours() * 60 + dt.getMinutes();
    const binIdx = Math.floor((minuteOfDay / 1440) * CONFIG.AGP_BINS);
    if (binIdx >= 0 && binIdx < CONFIG.AGP_BINS) {
      bins[binIdx].push(row.glucose);
    }
  });

  // Calculate percentiles for each bin
  return bins.map(bin => {
    if (bin.length === 0) return { p5: 0, p25: 0, p50: 0, p75: 0, p95: 0, mean: 0 };
    
    const sorted = [...bin].sort((a, b) => a - b);
    const mean = bin.reduce((a, b) => a + b, 0) / bin.length;
    
    return {
      p5: sorted[Math.floor(bin.length * 0.05)] || sorted[0],
      p25: sorted[Math.floor(bin.length * 0.25)],
      p50: sorted[Math.floor(bin.length * 0.50)],
      p75: sorted[Math.floor(bin.length * 0.75)],
      p95: sorted[Math.floor(bin.length * 0.95)] || sorted[sorted.length - 1],
      mean
    };
  });
};

/**
 * Detect hypoglycemic and hyperglycemic events
 * @param {Array} data - Array of glucose data objects
 * @param {string} startDate - Start date in YYYY/MM/DD format
 * @param {string} endDate - End date in YYYY/MM/DD format
 * @returns {Object} Object with hypoL1, hypoL2, hyper event counts and details
 */
export const detectEvents = (data, startDate, endDate) => {
  const filtered = data.filter(row => {
    const dt = utils.parseDate(row.date, row.time);
    const startDt = utils.parseDate(startDate, '00:00:00');
    const endDt = utils.parseDate(endDate, '23:59:59');
    return dt >= startDt && dt <= endDt;
  }).sort((a, b) => utils.parseDate(a.date, a.time) - utils.parseDate(b.date, b.time));

  const hypoL1 = [];
  const hypoL2 = [];
  const hyper = [];
  let currentEvent = null;

  filtered.forEach(row => {
    const glucose = row.glucose;
    const timestamp = utils.parseDate(row.date, row.time);
    const minuteOfDay = timestamp.getHours() * 60 + timestamp.getMinutes();

    if (glucose < CONFIG.GLUCOSE.CRITICAL_LOW) {
      // Level 2 hypoglycemia (<54 mg/dL)
      if (!currentEvent || currentEvent.type !== 'hypoL2') {
        currentEvent = { type: 'hypoL2', start: timestamp, minuteOfDay, startGlucose: glucose };
      }
    } else if (glucose < CONFIG.GLUCOSE.LOW) {
      // Level 1 hypoglycemia (54-69 mg/dL)
      if (currentEvent?.type === 'hypoL2') {
        const duration = Math.round((timestamp - currentEvent.start) / 60000);
        if (duration >= CONFIG.HYPO_MIN_DURATION) {
          hypoL2.push({ ...currentEvent, end: timestamp, duration });
        }
      }
      if (!currentEvent || currentEvent.type !== 'hypoL1') {
        currentEvent = { type: 'hypoL1', start: timestamp, minuteOfDay, startGlucose: glucose };
      }
    } else if (glucose > CONFIG.GLUCOSE.CRITICAL_HIGH) {
      // Hyperglycemia (>250 mg/dL)
      if (currentEvent?.type.startsWith('hypo')) {
        const duration = Math.round((timestamp - currentEvent.start) / 60000);
        if (duration >= CONFIG.HYPO_MIN_DURATION) {
          if (currentEvent.type === 'hypoL2') hypoL2.push({ ...currentEvent, end: timestamp, duration });
          if (currentEvent.type === 'hypoL1') hypoL1.push({ ...currentEvent, end: timestamp, duration });
        }
        currentEvent = null;
      }
      if (!currentEvent || currentEvent.type !== 'hyper') {
        currentEvent = { type: 'hyper', start: timestamp, minuteOfDay, startGlucose: glucose };
      }
    } else {
      // In range - close any open events
      if (currentEvent) {
        const duration = Math.round((timestamp - currentEvent.start) / 60000);
        if (currentEvent.type === 'hypoL2' && duration >= CONFIG.HYPO_MIN_DURATION) {
          hypoL2.push({ ...currentEvent, end: timestamp, duration });
        }
        if (currentEvent.type === 'hypoL1' && duration >= CONFIG.HYPO_MIN_DURATION) {
          hypoL1.push({ ...currentEvent, end: timestamp, duration });
        }
        if (currentEvent.type === 'hyper' && duration >= CONFIG.HYPER_MIN_DURATION) {
          hyper.push({ ...currentEvent, end: timestamp, duration });
        }
        currentEvent = null;
      }
    }
  });

  return {
    hypoL1: { count: hypoL1.length, events: hypoL1 },
    hypoL2: { count: hypoL2.length, events: hypoL2 },
    hyper: { count: hyper.length, events: hyper },
    totalHypo: hypoL1.length + hypoL2.length
  };
};
┌────────────────────────────────────────────────────────┐
│ FILE: src/core/parsers.js
└────────────────────────────────────────────────────────┘

/**
 * ARTIFACT-02: Data Parsers
 * CSV and ProTime data parsing utilities
 * 
 * Exports:
 * - parseCSV: Parse Medtronic CareLink CSV export
 * - parseProTime: Parse ProTime workday data (PDF text or JSON)
 * - exportProTimeJSON: Export workday data to JSON file
 */

import { CONFIG, utils } from './metrics-engine.js';

/**
 * Parse Medtronic CareLink CSV export
 * @param {string} text - Raw CSV text content
 * @returns {Array} Array of data objects {date, time, glucose, bolus, bg, carbs}
 * @throws {Error} If parsing fails or no valid data found
 */
export const parseCSV = (text) => {
  try {
    // Validate input
    if (!text || text.trim().length === 0) {
      throw new Error('CSV file is empty');
    }
    
    const lines = text.split('\n');
    
    // Check minimum line count
    if (lines.length < CONFIG.CSV_SKIP_LINES + 10) {
      throw new Error(`CSV file too short. Expected at least ${CONFIG.CSV_SKIP_LINES + 10} lines, got ${lines.length}`);
    }
    
    // Skip header lines (first 6 lines are metadata)
    const dataLines = lines.slice(CONFIG.CSV_SKIP_LINES);
    
    // Validate CSV structure by checking first data line
    const firstDataLine = dataLines.find(line => line.trim());
    if (!firstDataLine) {
      throw new Error('No data rows found in CSV after header');
    }
    
    const sampleParts = firstDataLine.split(';');
    if (sampleParts.length < 35) {
      throw new Error(`Invalid CSV format. Expected at least 35 columns, found ${sampleParts.length}. Is this a CareLink export?`);
    }
    
    // Parse data rows
    let validRows = 0;
    let skippedRows = 0;
    
    const data = dataLines
      .filter(line => line.trim())
      .map((line, index) => {
        const parts = line.split(';');
        
        // Validate column count
        if (parts.length < 35) {
          skippedRows++;
          return null;
        }
        
        // Parse glucose value (required)
        const glucose = utils.parseDecimal(parts[34]);
        if (isNaN(glucose)) {
          skippedRows++;
          return null;
        }
        
        // Validate glucose range (40-400 mg/dL is reasonable)
        if (glucose < 40 || glucose > 400) {
          console.warn(`Suspicious glucose value at row ${index + CONFIG.CSV_SKIP_LINES}: ${glucose} mg/dL`);
        }
        
        validRows++;
        
        // Parse optional fields
        return {
          date: parts[1],           // YYYY/MM/DD
          time: parts[2],           // HH:MM:SS
          glucose,                  // mg/dL
          bolus: utils.parseDecimal(parts[20]) || 0,
          bg: utils.parseDecimal(parts[18]) || null,
          carbs: utils.parseDecimal(parts[27]) || 0
        };
      })
      .filter(row => row !== null);
    
    if (data.length === 0) {
      throw new Error(`No valid glucose data found. Checked ${dataLines.length} rows, all were invalid.`);
    }
    
    // Calculate coverage
    const coverage = (validRows / (validRows + skippedRows) * 100).toFixed(1);
    console.info(`CSV parsed successfully: ${validRows} valid rows (${coverage}% coverage), ${skippedRows} skipped`);
    
    // Warn if coverage is low
    if (coverage < 70) {
      console.warn(`⚠️ Low data coverage: ${coverage}%. Metrics may be unreliable.`);
    }
    
    return data;
    
  } catch (err) {
    // Provide helpful error messages
    if (err.message.includes('CSV')) {
      throw err; // Already a helpful error
    }
    throw new Error(`CSV parsing failed: ${err.message}. Please ensure this is a valid CareLink export.`);
  }
};

/**
 * Parse ProTime workday data from multiple formats
 * Supports:
 * 1. PDF text (copy-pasted from ProTime PDF)
 *    - Automatically extracts year from PDF header (e.g., "Gegenereerd op 22/10/2025")
 *    - Falls back to "Week XX YYYY" headers if present
 *    - Uses current year as final fallback
 *    - Supports Dutch day abbreviations (ma, di, wo, do, vr, za, zo)
 *    - Filters out free days ("-" in time columns) and absent days
 * 2. JSON array: ["2024/10/01", "2024/10/02"]
 * 3. JSON object with workdays array: {workdays: ["2024/10/01"]}
 * 4. JSON object with date:boolean pairs: {"2024/10/01": true}
 * 
 * @param {string} input - Raw input text (PDF text or JSON string)
 * @returns {Set<string>} Set of workday dates in YYYY/MM/DD format
 * @throws {Error} If parsing fails or no workdays found
 */
export const parseProTime = (input) => {
  // Try JSON parsing first
  try {
    const data = JSON.parse(input);
    const workdays = new Set();
    
    // Format 1: {workdays: [{date, is_workday}, ...]} - Rich format with metadata
    if (data.workdays && Array.isArray(data.workdays) && data.workdays.length > 0 && typeof data.workdays[0] === 'object') {
      data.workdays.forEach(entry => {
        // Check if is_workday is truthy (could be boolean true, or a time string like "22:00")
        if (entry.date && entry.is_workday) {
          // Normalize date format to YYYY/MM/DD
          const normalizedDate = entry.date.replace(/-/g, '/');
          workdays.add(normalizedDate);
        }
      });
    }
    // Format 2: {workdays: ["date1", "date2"]} - Simple array
    else if (data.workdays && Array.isArray(data.workdays)) {
      data.workdays.forEach(d => {
        workdays.add(d.replace(/-/g, '/'));
      });
    }
    // Format 3: ["date1", "date2"] - Direct array
    else if (Array.isArray(data)) {
      data.forEach(d => {
        workdays.add(d.replace(/-/g, '/'));
      });
    }
    // Format 4: {date: bool, ...} - Object with date keys
    else if (typeof data === 'object') {
      Object.entries(data)
        .filter(([_, val]) => val === true)
        .forEach(([date, _]) => {
          workdays.add(date.replace(/-/g, '/'));
        });
    }
    
    if (workdays.size > 0) return workdays;
    
  } catch (e) {
    // Not JSON, try PDF text parsing
  }
  
  // PDF text parsing
  const workdays = new Set();
  let currentYear = new Date().getFullYear();
  
  const lines = input.split('\n');
  
  // Try to extract year from PDF header first (ProTime exports)
  // Format: "Gegenereerd op 22/10/2025" or similar date in header
  const headerYearMatch = input.match(/\b(\d{1,2})\/(\d{1,2})\/(20\d{2})\b/);
  if (headerYearMatch) {
    currentYear = parseInt(headerYearMatch[3]);
  }
  
  lines.forEach((line) => {
    // Extract year from "Week XX YYYY" headers (if present)
    const yearMatch = line.match(/Week\s+\d+\s+(20\d{2})/);
    if (yearMatch) {
      currentYear = parseInt(yearMatch[1]);
      return;
    }
    
    // Match lines with date format: day DD/MM
    // Use \s+ to match multiple spaces (common in PDF extraction)
    // Example: "wo 01/10   8:52   17:03" or "ma 06/10   11:34   19:46"
    const dateMatch = line.match(/(ma|di|wo|do|vr|za|zo)\s+(\d{1,2})\/(\d{1,2})/);
    
    if (dateMatch) {
      const [_, dayAbbr, dayNum, month] = dateMatch;
      
      // Check if this is a work day by looking for time values (HH:MM format)
      // And exclude lines with "Vrije Dag", "Vakantie", or "OA Var" (vacation code)
      const hasTimeFormat = /\d{1,2}:\d{2}/.test(line);
      const isVacation = line.includes('Vakantie') || line.includes('OA Var');
      const isFreeDay = line.includes('OZ Vrije Dag') || line.includes('Vrije Dag');
      
      // Only count as workday if:
      // 1. Has actual time entries (HH:MM format)
      // 2. Not a vacation day (no "Vakantie" or "OA Var")
      // 3. Not a free day (no "Vrije Dag")
      if (hasTimeFormat && !isVacation && !isFreeDay) {
        const paddedMonth = month.padStart(2, '0');
        const paddedDay = dayNum.padStart(2, '0');
        const dateStr = `${currentYear}/${paddedMonth}/${paddedDay}`;
        workdays.add(dateStr);
      }
    }
  });
  
  if (workdays.size > 0) return workdays;
  
  throw new Error('Could not parse ProTime data. Expected PDF text or JSON format.');
};

/**
 * Export workday data to JSON file
 * @param {Set<string>} workdays - Set of workday dates in YYYY/MM/DD format
 * @returns {string} JSON string ready for download
 */
export const exportProTimeJSON = (workdays) => {
  const data = {
    source: 'ProTime',
    exported: new Date().toISOString(),
    format: 'YYYY/MM/DD',
    count: workdays.size,
    workdays: Array.from(workdays).sort()
  };
  
  return JSON.stringify(data, null, 2);
};

/**
 * Trigger browser download of JSON file
 * @param {Set<string>} workdays - Set of workday dates
 */
export const downloadProTimeJSON = (workdays) => {
  const json = exportProTimeJSON(workdays);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `workdays_${new Date().toISOString().split('T')[0]}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};
┌────────────────────────────────────────────────────────┐
│ FILE: src/core/html-exporter.js
└────────────────────────────────────────────────────────┘

/**
 * ARTIFACT-03: HTML Exporter
 * Generate standalone HTML reports for AGP analysis
 * 
 * Design principles:
 * - Print-optimized (A4, black/white, high contrast)
 * - Information density (minimal whitespace)
 * - Clear visual hierarchy
 * - Self-contained (no external dependencies)
 * 
 * Exports:
 * - generateHTML: Create complete HTML document
 * - downloadHTML: Trigger browser download
 */

import { CONFIG } from './metrics-engine.js';

/**
 * Generate SVG path data for AGP curve
 */
const generateAGPPath = (agpData, percentile) => {
  return agpData.map((d, i) => {
    const x = 60 + (i / CONFIG.AGP_BINS) * 780;
    const y = 350 - ((d[percentile] / CONFIG.GLUCOSE.MAX) * 300);
    return `${i === 0 ? 'M' : 'L'} ${x} ${y}`;
  }).join(' ');
};

/**
 * Generate SVG path for filled AGP band
 */
const generateAGPBand = (agpData, topPercentile, bottomPercentile) => {
  const topPath = agpData.map((d, i) => {
    const x = 60 + (i / CONFIG.AGP_BINS) * 780;
    const y = 350 - ((d[topPercentile] / CONFIG.GLUCOSE.MAX) * 300);
    return `${x},${y}`;
  }).join(' L ');
  
  const bottomPath = agpData.slice().reverse().map((d, i) => {
    const reverseIdx = CONFIG.AGP_BINS - 1 - i;
    const x = 60 + (reverseIdx / CONFIG.AGP_BINS) * 780;
    const y = 350 - ((d[bottomPercentile] / CONFIG.GLUCOSE.MAX) * 300);
    return `${x},${y}`;
  }).join(' L ');
  
  return `M ${topPath} L ${bottomPath} Z`;
};

/**
 * Generate complete HTML report
 */
export const generateHTML = (options) => {
  const {
    metrics,
    agpData,
    events,
    startDate,
    endDate,
    dayNightMetrics = null,
    workdaySplit = null,
    comparison = null
  } = options;

  // Validate required data
  if (!metrics || !agpData || !startDate || !endDate) {
    console.error('generateHTML: Missing required data', { metrics: !!metrics, agpData: !!agpData, startDate: !!startDate, endDate: !!endDate });
    throw new Error('Missing required data for HTML generation');
  }

  const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AGP+ Report - ${startDate} to ${endDate}</title>
  <style>
    /* ===================================================================
       AGP+ HTML EXPORT - BRUTALIST PRINT DESIGN
       Matches screen version: Monospace, uppercase, massive borders
       Optimized for: B/W printing, high contrast, information density
       =================================================================== */
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: "SF Mono", "Monaco", "Courier New", "Courier", monospace;
      font-size: 9pt;
      line-height: 1.4;
      color: #000;
      background: #fff;
      padding: 8mm;
      /* Sharp edges, no smoothing */
      -webkit-font-smoothing: none;
      -moz-osx-font-smoothing: grayscale;
    }
    
    @media print {
      body {
        padding: 5mm;
      }
      
      .page-break {
        page-break-before: always;
      }
      
      @page {
        size: A4;
        margin: 5mm;
      }
    }
    
    /* Header - Brutalist */
    .header {
      border: 3px solid #000;
      padding: 4mm;
      margin-bottom: 5mm;
      background: #000;
      color: #fff;
    }
    
    h1 {
      font-size: 18pt;
      font-weight: 700;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      margin-bottom: 2mm;
    }
    
    .subtitle {
      font-size: 8pt;
      font-weight: 700;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      opacity: 0.8;
    }
    
    /* Section spacing */
    .section {
      margin-bottom: 6mm;
    }
    
    h2 {
      font-size: 11pt;
      font-weight: 700;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 3mm;
      padding: 2mm;
      border: 2px solid #000;
      background: #000;
      color: #fff;
    }
    
    /* Metrics Grid - Compact 4-column, BRUTALIST borders */
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 3mm;
      margin-bottom: 4mm;
    }
    
    .metric-card {
      border: 3px solid #000;
      padding: 3mm;
    }
    
    .metric-label {
      font-size: 7pt;
      font-weight: 700;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 2mm;
    }
    
    .metric-value {
      font-size: 20pt;
      font-weight: 700;
      line-height: 1;
      font-variant-numeric: tabular-nums;
      letter-spacing: -0.02em;
    }
    
    .metric-subtitle {
      font-size: 6pt;
      margin-top: 2mm;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      opacity: 0.7;
    }
    
    /* TIR Bar - High contrast, BRUTALIST */
    .tir-bar {
      display: flex;
      height: 10mm;
      border: 3px solid #000;
      margin-bottom: 3mm;
    }
    
    .tir-segment {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8pt;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      border-right: 2px solid #000;
    }
    
    .tir-segment:last-child {
      border-right: none;
    }
    
    /* Patterns for print clarity - AGGRESSIVE CONTRAST */
    .tir-tbr { 
      background: repeating-linear-gradient(
        45deg,
        #fff,
        #fff 2px,
        #000 2px,
        #000 4px
      );
    }
    .tir-tir { 
      background: #000; 
      color: #fff; 
    }
    .tir-tar { 
      background: #ddd; 
    }
    
    .tir-legend {
      display: flex;
      justify-content: space-between;
      font-size: 7pt;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 4mm;
    }
    
    /* SVG - BRUTALIST borders */
    svg {
      border: 3px solid #000;
      background: #fff;
      margin-bottom: 4mm;
    }
    
    /* Details Grid - Compact 2-column, BRUTALIST */
    .details-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 3mm;
      margin-bottom: 4mm;
    }
    
    .details-card {
      border: 3px solid #000;
      padding: 3mm;
    }
    
    .detail-row {
      display: flex;
      justify-content: space-between;
      padding: 2mm 0;
      border-bottom: 1px solid #000;
      font-size: 8pt;
    }
    
    .detail-row:last-child {
      border-bottom: none;
    }
    
    .detail-label {
      font-weight: 400;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .detail-value {
      font-weight: 700;
      font-variant-numeric: tabular-nums;
    }
    
    /* Event Summary - BRUTALIST style */
    .event-summary {
      display: flex;
      gap: 3mm;
      margin-top: 4mm;
    }
    
    .event-card {
      flex: 1;
      border: 3px solid #000;
      padding: 3mm;
      text-align: center;
    }
    
    .event-label {
      font-size: 7pt;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 2mm;
    }
    
    .event-count {
      font-size: 18pt;
      font-weight: 700;
      line-height: 1;
    }
    
    /* Comparison Grid - BRUTALIST 3 columns */
    .comparison-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 3mm;
      margin-top: 4mm;
    }
    
    .comparison-card {
      border: 3px solid #000;
      padding: 3mm;
    }
    
    .comparison-label {
      font-size: 7pt;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 2mm;
    }
    
    .comparison-values {
      display: flex;
      align-items: baseline;
      gap: 2mm;
      font-size: 10pt;
      margin-bottom: 1mm;
    }
    
    .comparison-old {
      color: #666;
      font-variant-numeric: tabular-nums;
    }
    
    .comparison-arrow {
      font-weight: 700;
    }
    
    .comparison-new {
      font-size: 16pt;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
    }
    
    .comparison-delta {
      font-size: 8pt;
      font-weight: 700;
      text-transform: uppercase;
    }
    
    /* Split Grid - BRUTALIST 2 columns */
    .split-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 3mm;
      margin-top: 4mm;
    }
    
    .split-card {
      border: 3px solid #000;
      padding: 3mm;
    }
    
    .split-header {
      font-size: 9pt;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 2mm;
      padding-bottom: 2mm;
      border-bottom: 2px solid #000;
    }
    
    .split-info {
      font-size: 7pt;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      opacity: 0.7;
      margin-bottom: 2mm;
    }
    
    /* Footer - BRUTALIST */
    .footer {
      margin-top: 6mm;
      padding: 3mm;
      border: 3px solid #000;
      background: #000;
      color: #fff;
      font-size: 6pt;
      font-weight: 700;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>AGP+ V2.1</h1>
    <div class="subtitle">AMBULATORY GLUCOSE PROFILE | ${startDate} → ${endDate} (${metrics.days} DAYS) | GENERATED: ${new Date().toLocaleDateString('nl-NL').toUpperCase()}</div>
  </div>

  <div class="section">
    <h2>GLUCOSE METRICS</h2>
    
    <div class="metrics-grid">
      <div class="metric-card">
        <div class="metric-label">TIME IN RANGE</div>
        <div class="metric-value">${metrics.tir}%</div>
        <div class="metric-subtitle">Target &gt;70%</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">MEAN ± SD</div>
        <div class="metric-value">${metrics.mean}</div>
        <div class="metric-subtitle">± ${metrics.sd} mg/dL</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">CV</div>
        <div class="metric-value">${metrics.cv}%</div>
        <div class="metric-subtitle">Target ≤36%</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">GMI</div>
        <div class="metric-value">${metrics.gmi}%</div>
        <div class="metric-subtitle">Est. HbA1c</div>
      </div>
    </div>
    
    <div class="details-grid">
      <div class="details-card">
        <div class="detail-row">
          <span class="detail-label">MAGE (glycemic excursion)</span>
          <span class="detail-value">${metrics.mage} mg/dL</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">MODD (day-to-day variability)</span>
          <span class="detail-value">${metrics.modd} mg/dL</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">TAR (time above 180 mg/dL)</span>
          <span class="detail-value">${metrics.tar}%</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">TBR (time below 70 mg/dL)</span>
          <span class="detail-value">${metrics.tbr}%</span>
        </div>
      </div>
      <div class="details-card">
        <div class="detail-row">
          <span class="detail-label">Minimum</span>
          <span class="detail-value">${metrics.min} mg/dL</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">Maximum</span>
          <span class="detail-value">${metrics.max} mg/dL</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">Days analyzed</span>
          <span class="detail-value">${metrics.days}</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">Total readings</span>
          <span class="detail-value">${metrics.readingCount}</span>
        </div>
      </div>
    </div>
  </div>

  <div class="section">
    <h2>AMBULATORY GLUCOSE PROFILE</h2>
    
    <div class="tir-bar">
      <div class="tir-segment tir-tbr" style="width: ${metrics.tbr}%">
        ${parseFloat(metrics.tbr) > 8 ? `${metrics.tbr}%` : ''}
      </div>
      <div class="tir-segment tir-tir" style="width: ${metrics.tir}%">
        ${metrics.tir}%
      </div>
      <div class="tir-segment tir-tar" style="width: ${metrics.tar}%">
        ${parseFloat(metrics.tar) > 8 ? `${metrics.tar}%` : ''}
      </div>
    </div>
    
    <div class="tir-legend">
      <span><strong>TBR</strong> &lt;70 mg/dL (striped)</span>
      <span><strong>TIR</strong> 70-180 mg/dL (black - TARGET)</span>
      <span><strong>TAR</strong> &gt;180 mg/dL (gray)</span>
    </div>
    
    <svg viewBox="0 0 900 450" width="100%">
      <!-- Grid lines - critical thresholds -->
      <line x1="60" y1="${350 - (54/400)*300}" x2="840" y2="${350 - (54/400)*300}" 
        stroke="#000" stroke-width="2" stroke-dasharray="8,4" />
      <line x1="60" y1="${350 - (70/400)*300}" x2="840" y2="${350 - (70/400)*300}" 
        stroke="#000" stroke-width="3" />
      <line x1="60" y1="${350 - (180/400)*300}" x2="840" y2="${350 - (180/400)*300}" 
        stroke="#000" stroke-width="3" />
      <line x1="60" y1="${350 - (250/400)*300}" x2="840" y2="${350 - (250/400)*300}" 
        stroke="#000" stroke-width="2" stroke-dasharray="8,4" />
      
      <!-- Y-axis labels -->
      <text x="45" y="${350 - (54/400)*300 + 5}" font-size="12" font-weight="bold" text-anchor="end">54</text>
      <text x="45" y="${350 - (70/400)*300 + 5}" font-size="13" font-weight="bold" text-anchor="end">70</text>
      <text x="45" y="${350 - (180/400)*300 + 5}" font-size="13" font-weight="bold" text-anchor="end">180</text>
      <text x="45" y="${350 - (250/400)*300 + 5}" font-size="12" font-weight="bold" text-anchor="end">250</text>
      <text x="45" y="355" font-size="11" text-anchor="end">0</text>
      <text x="45" y="55" font-size="11" text-anchor="end">400</text>
      <text x="20" y="210" font-size="11" font-weight="bold" text-anchor="middle" transform="rotate(-90 20 210)">mg/dL</text>
      
      <!-- X-axis -->
      ${[0, 3, 6, 9, 12, 15, 18, 21, 24].map(hour => {
        const x = 60 + (hour / 24) * 780;
        return `
          <line x1="${x}" y1="50" x2="${x}" y2="360" stroke="#ccc" stroke-width="1" />
          <text x="${x}" y="375" font-size="11" text-anchor="middle">${String(hour).padStart(2, '0')}:00</text>
        `;
      }).join('')}
      <text x="450" y="395" font-size="11" font-weight="bold" text-anchor="middle">Time of Day</text>
      
      <!-- AGP bands - higher contrast -->
      <path d="${generateAGPBand(agpData, 'p5', 'p95')}" fill="#ddd" />
      <path d="${generateAGPBand(agpData, 'p25', 'p75')}" fill="#aaa" />
      
      <!-- Median line - thick black -->
      <path d="${generateAGPPath(agpData, 'p50')}" stroke="#000" stroke-width="3" fill="none" />
      
      <!-- Mean line - dashed -->
      <path d="${generateAGPPath(agpData, 'mean')}" stroke="#666" stroke-width="2" stroke-dasharray="6,3" fill="none" />
      
      ${comparison ? `
      <!-- Comparison median - dotted -->
      <path d="${generateAGPPath(comparison.comparisonAGP, 'p50')}" stroke="#000" stroke-width="2" stroke-dasharray="2,4" fill="none" />
      ` : ''}
      
      <!-- Legend box -->
      <rect x="680" y="60" width="150" height="${comparison ? '110' : '90'}" fill="#fff" stroke="#000" stroke-width="2" />
      <text x="755" y="78" font-size="11" font-weight="bold" text-anchor="middle">LEGEND</text>
      <line x1="690" y1="85" x2="720" y2="85" stroke="#000" stroke-width="3" />
      <text x="725" y="88" font-size="10">Median (p50)</text>
      <line x1="690" y1="100" x2="720" y2="100" stroke="#666" stroke-width="2" stroke-dasharray="6,3" />
      <text x="725" y="103" font-size="10">Mean</text>
      ${comparison ? `
      <line x1="690" y1="115" x2="720" y2="115" stroke="#000" stroke-width="2" stroke-dasharray="2,4" />
      <text x="725" y="118" font-size="10">Previous</text>
      ` : ''}
      <rect x="690" y="${comparison ? '125' : '110'}" width="30" height="8" fill="#aaa" />
      <text x="725" y="${comparison ? '132' : '117'}" font-size="10">IQR (p25-p75)</text>
      <rect x="690" y="${comparison ? '140' : '125'}" width="30" height="8" fill="#ddd" />
      <text x="725" y="${comparison ? '147' : '132'}" font-size="10">p5-p95</text>
    </svg>
    
    <div class="event-summary">
      <div class="event-card">
        <div class="event-label">HYPO L2 (&lt;54)</div>
        <div class="event-count">${events.hypoL2.count}</div>
      </div>
      <div class="event-card">
        <div class="event-label">HYPO L1 (54-69)</div>
        <div class="event-count">${events.hypoL1.count}</div>
      </div>
      <div class="event-card">
        <div class="event-label">HYPER (&gt;250)</div>
        <div class="event-count">${events.hyper.count}</div>
      </div>
    </div>
  </div>

  ${comparison ? `
  <div class="section page-break">
    <h2>PERIOD COMPARISON</h2>
    <div class="split-info">
      Previous: ${comparison.prevStart} to ${comparison.prevEnd} | Current: ${startDate} to ${endDate}
    </div>
    
    <div class="comparison-grid">
      <div class="comparison-card">
        <div class="comparison-label">TIME IN RANGE</div>
        <div class="comparison-values">
          <span class="comparison-old">${comparison.previous.tir}%</span>
          <span class="comparison-arrow">→</span>
          <span class="comparison-new">${metrics.tir}%</span>
        </div>
        <div class="comparison-delta">
          ${(parseFloat(metrics.tir) - parseFloat(comparison.previous.tir)) > 0 ? '▲' : '▼'} 
          ${Math.abs(parseFloat(metrics.tir) - parseFloat(comparison.previous.tir)).toFixed(1)}%
        </div>
      </div>
      <div class="comparison-card">
        <div class="comparison-label">MEAN ± SD</div>
        <div class="comparison-values">
          <span class="comparison-old">${comparison.previous.mean}±${comparison.previous.sd}</span>
          <span class="comparison-arrow">→</span>
          <span class="comparison-new">${metrics.mean}±${metrics.sd}</span>
        </div>
        <div class="comparison-delta">
          ${metrics.mean - comparison.previous.mean > 0 ? '▲' : '▼'} 
          ${Math.abs(metrics.mean - comparison.previous.mean)} mg/dL
        </div>
      </div>
      <div class="comparison-card">
        <div class="comparison-label">CV (VARIABILITY)</div>
        <div class="comparison-values">
          <span class="comparison-old">${comparison.previous.cv}%</span>
          <span class="comparison-arrow">→</span>
          <span class="comparison-new">${metrics.cv}%</span>
        </div>
        <div class="comparison-delta">
          ${(parseFloat(metrics.cv) - parseFloat(comparison.previous.cv)) > 0 ? '▲' : '▼'} 
          ${Math.abs(parseFloat(metrics.cv) - parseFloat(comparison.previous.cv)).toFixed(1)}%
        </div>
      </div>
    </div>
  </div>
  ` : ''}

  ${dayNightMetrics ? `
  <div class="section">
    <h2>DAY VS NIGHT ANALYSIS</h2>
    <div class="split-info">Night: 00:00-06:00 (6h) | Day: 06:00-00:00 (18h)</div>
    
    <div class="split-grid">
      <div class="split-card">
        <div class="split-header">DAY (06:00-00:00)</div>
        <div class="detail-row">
          <span class="detail-label">Time in Range</span>
          <span class="detail-value">${dayNightMetrics.day.tir}%</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">Mean ± SD</span>
          <span class="detail-value">${dayNightMetrics.day.mean} ± ${dayNightMetrics.day.sd}</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">CV</span>
          <span class="detail-value">${dayNightMetrics.day.cv}%</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">Readings</span>
          <span class="detail-value">${dayNightMetrics.day.readingCount}</span>
        </div>
      </div>
      <div class="split-card">
        <div class="split-header">NIGHT (00:00-06:00)</div>
        <div class="detail-row">
          <span class="detail-label">Time in Range</span>
          <span class="detail-value">${dayNightMetrics.night.tir}%</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">Mean ± SD</span>
          <span class="detail-value">${dayNightMetrics.night.mean} ± ${dayNightMetrics.night.sd}</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">CV</span>
          <span class="detail-value">${dayNightMetrics.night.cv}%</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">Readings</span>
          <span class="detail-value">${dayNightMetrics.night.readingCount}</span>
        </div>
      </div>
    </div>
  </div>
  ` : ''}

  ${workdaySplit ? `
  <div class="section">
    <h2>WORKDAY VS REST DAY ANALYSIS</h2>
    <div class="split-info">Workdays: ${workdaySplit.workdayCount} | Rest days: ${workdaySplit.restdayCount}</div>
    
    <div class="split-grid">
      <div class="split-card">
        <div class="split-header">WORKDAYS (${workdaySplit.workdayCount} days)</div>
        <div class="detail-row">
          <span class="detail-label">Time in Range</span>
          <span class="detail-value">${workdaySplit.workday.tir}%</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">Mean ± SD</span>
          <span class="detail-value">${workdaySplit.workday.mean} ± ${workdaySplit.workday.sd}</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">CV</span>
          <span class="detail-value">${workdaySplit.workday.cv}%</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">MAGE</span>
          <span class="detail-value">${workdaySplit.workday.mage}</span>
        </div>
      </div>
      <div class="split-card">
        <div class="split-header">REST DAYS (${workdaySplit.restdayCount} days)</div>
        <div class="detail-row">
          <span class="detail-label">Time in Range</span>
          <span class="detail-value">${workdaySplit.restday.tir}%</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">Mean ± SD</span>
          <span class="detail-value">${workdaySplit.restday.mean} ± ${workdaySplit.restday.sd}</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">CV</span>
          <span class="detail-value">${workdaySplit.restday.cv}%</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">MAGE</span>
          <span class="detail-value">${workdaySplit.restday.mage}</span>
        </div>
      </div>
    </div>
  </div>
  ` : ''}

  <div class="footer">
    AGP+ V2.1 | MINIMED 780G + GUARDIAN 4 | ADA/ATTD 2019 GUIDELINES | PRINT-OPTIMIZED BRUTALIST DESIGN
  </div>
</body>
</html>`;

  return html;
};

/**
 * Trigger browser download of HTML report
 */
export const downloadHTML = (options) => {
  const html = generateHTML(options);
  const blob = new Blob([html], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  
  // Generate unique filename with timestamp
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5); // YYYY-MM-DDTHH-MM-SS
  a.download = `AGP_Report_${timestamp}.html`;
  
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};
┌────────────────────────────────────────────────────────┐
│ FILE: src/hooks/useCSVData.js
└────────────────────────────────────────────────────────┘

import { useState, useCallback } from 'react';
import { parseCSV } from '../core/parsers.js';

/**
 * useCSVData - Custom hook for CSV data management
 * 
 * Handles CSV parsing, date range extraction, and data state management.
 * 
 * @returns {Object} CSV data state and handlers
 * @returns {Array|null} csvData - Parsed CSV data array
 * @returns {Object|null} dateRange - { min: Date, max: Date }
 * @returns {Function} loadCSV - Load CSV from text: (text) => void
 * @returns {Function} clearCSV - Clear loaded CSV data
 * @returns {string|null} error - Error message if parsing failed
 * 
 * @version 2.1.0
 */
export function useCSVData() {
  const [csvData, setCsvData] = useState(null);
  const [dateRange, setDateRange] = useState(null);
  const [error, setError] = useState(null);

  /**
   * Load and parse CSV text
   */
  const loadCSV = useCallback((text) => {
    setError(null);
    
    try {
      // Parse CSV using core parser
      const data = parseCSV(text);
      
      if (data.length === 0) {
        throw new Error('No valid data found in CSV');
      }

      // Extract date range from data
      const dates = data.map(row => {
        const [year, month, day] = row.date.split('/');
        return new Date(year, month - 1, day);
      });

      const minDate = new Date(Math.min(...dates));
      const maxDate = new Date(Math.max(...dates));

      // Update state
      setCsvData(data);
      setDateRange({ min: minDate, max: maxDate });
      
    } catch (err) {
      setError(err.message);
      setCsvData(null);
      setDateRange(null);
    }
  }, []);

  /**
   * Clear loaded CSV data
   */
  const clearCSV = useCallback(() => {
    setCsvData(null);
    setDateRange(null);
    setError(null);
  }, []);

  return {
    csvData,
    dateRange,
    loadCSV,
    clearCSV,
    error,
  };
}

┌────────────────────────────────────────────────────────┐
│ FILE: src/hooks/useMetrics.js
└────────────────────────────────────────────────────────┘

import { useMemo } from 'react';
import { calculateMetrics, calculateAGP, detectEvents } from '../core/metrics-engine.js';

/**
 * Convert Date object to YYYY/MM/DD string format
 */
const formatDateForMetrics = (date) => {
  if (!date) return null;
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}/${month}/${day}`;
};

/**
 * useMetrics - Custom hook for glucose metrics calculation
 * 
 * Wraps core calculation functions with React memoization for performance.
 * Only recalculates when dependencies change.
 * 
 * @param {Array} csvData - Parsed CSV data
 * @param {Date} startDate - Analysis period start
 * @param {Date} endDate - Analysis period end
 * @param {Set|null} workdays - Set of workday date strings (optional)
 * 
 * @returns {Object|null} Calculated metrics and AGP data
 * @returns {Object} metrics - Clinical metrics (TIR, CV, etc.)
 * @returns {Array} agp - AGP percentile data (288 bins)
 * @returns {Object} events - Detected hypo/hyper events
 * @returns {Object|null} dayMetrics - Day period metrics (06:00-00:00)
 * @returns {Object|null} nightMetrics - Night period metrics (00:00-06:00)
 * @returns {Object|null} workdayMetrics - Workday metrics (if workdays provided)
 * @returns {Object|null} restdayMetrics - Rest day metrics (if workdays provided)
 * 
 * @version 2.1.0
 */
export function useMetrics(csvData, startDate, endDate, workdays = null) {
  return useMemo(() => {
    if (!csvData || !startDate || !endDate) {
      return null;
    }

    try {
      // Convert Date objects to string format expected by metrics engine
      const startStr = formatDateForMetrics(startDate);
      const endStr = formatDateForMetrics(endDate);

      // Calculate main metrics
      const metrics = calculateMetrics(csvData, startStr, endStr);
      
      // Calculate AGP percentiles
      const agp = calculateAGP(csvData, startStr, endStr);
      
      // Detect events
      const events = detectEvents(csvData, startStr, endStr);

      // Calculate day/night split metrics
      const dayMetrics = calculateMetrics(csvData, startStr, endStr, null, { 
        type: 'day_night',
        value: 'day' 
      });
      const nightMetrics = calculateMetrics(csvData, startStr, endStr, null, { 
        type: 'day_night',
        value: 'night' 
      });

      // Calculate workday/restday split metrics (if workdays provided)
      let workdayMetrics = null;
      let restdayMetrics = null;
      
      if (workdays && workdays.size > 0) {
        workdayMetrics = calculateMetrics(csvData, startStr, endStr, workdays, null);
        
        // For restdays, we need to filter OUT the workdays
        // Create inverted set
        const allDates = new Set(csvData.map(row => row.date));
        const restdays = new Set([...allDates].filter(date => !workdays.has(date)));
        restdayMetrics = calculateMetrics(csvData, startStr, endStr, restdays, null);
      }

      return {
        metrics,
        agp,
        events,
        dayMetrics,
        nightMetrics,
        workdayMetrics,
        restdayMetrics,
      };

    } catch (err) {
      console.error('Metrics calculation failed:', err);
      return null;
    }
  }, [csvData, startDate, endDate, workdays]);
}

┌────────────────────────────────────────────────────────┐
│ FILE: src/hooks/useComparison.js
└────────────────────────────────────────────────────────┘

import { useState, useEffect } from 'react';
import { calculateMetrics, calculateAGP } from '../core/metrics-engine.js';
import { CONFIG } from '../core/metrics-engine.js';

/**
 * Convert Date object to YYYY/MM/DD string format
 */
const formatDateForMetrics = (date) => {
  if (!date) return null;
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}/${month}/${day}`;
};

/**
 * useComparison - Custom hook for period comparison logic
 * 
 * Automatically triggers comparison calculation when:
 * 1. A preset period is selected (14/30/90 days)
 * 2. Sufficient historical data is available
 * 
 * Calculates metrics for the previous period of equal length.
 * 
 * @param {Array} csvData - Parsed CSV data
 * @param {Date} startDate - Current period start
 * @param {Date} endDate - Current period end
 * @param {Object} dateRange - { min: Date, max: Date } available data range
 * 
 * @returns {Object|null} Comparison data or null if not applicable
 * @returns {Object} comparison - Previous period metrics
 * @returns {Array} comparisonAGP - Previous period AGP data
 * @returns {Date} prevStart - Previous period start date
 * @returns {Date} prevEnd - Previous period end date
 * 
 * @version 2.1.0
 */
export function useComparison(csvData, startDate, endDate, dateRange) {
  const [comparisonData, setComparisonData] = useState(null);

  useEffect(() => {
    if (!csvData || !startDate || !endDate || !dateRange) {
      // Only log if we previously had comparison data (state change from something to nothing)
      if (comparisonData !== null) {
        console.log('useComparison: Clearing comparison data');
      }
      setComparisonData(null);
      return;
    }

    try {
      // Calculate current period length in days
      const currentPeriodDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
      console.log('useComparison: Current period days:', currentPeriodDays);

      // Only auto-compare for 14 and 30 day periods (not 90 days - too long)
      const isPresetPeriod = [14, 30].includes(currentPeriodDays);
      console.log('useComparison: Is preset period?', isPresetPeriod);
      
      if (!isPresetPeriod) {
        setComparisonData(null);
        return;
      }

      // Calculate previous period dates
      const prevEnd = new Date(startDate);
      prevEnd.setDate(prevEnd.getDate() - 1); // Day before current start
      
      const prevStart = new Date(prevEnd);
      prevStart.setDate(prevStart.getDate() - currentPeriodDays + 1);

      console.log('useComparison: Previous period:', {
        prevStart: prevStart.toISOString(),
        prevEnd: prevEnd.toISOString(),
        dataRangeMin: dateRange.min.toISOString()
      });

      // Check if previous period has sufficient data
      if (prevStart < dateRange.min) {
        console.log('useComparison: Not enough historical data');
        setComparisonData(null);
        return;
      }

      // Calculate metrics for previous period
      const prevStartStr = formatDateForMetrics(prevStart);
      const prevEndStr = formatDateForMetrics(prevEnd);
      console.log('useComparison: Calculating metrics for', prevStartStr, 'to', prevEndStr);
      
      const comparison = calculateMetrics(csvData, prevStartStr, prevEndStr);
      const comparisonAGP = calculateAGP(csvData, prevStartStr, prevEndStr);

      console.log('useComparison: Comparison result', {
        hasComparison: !!comparison,
        hasAGP: !!comparisonAGP,
        readingCount: comparison?.readingCount
      });

      // Verify we have valid data
      if (!comparison || !comparisonAGP || comparison.readingCount < 100) {
        console.log('useComparison: Insufficient comparison data');
        setComparisonData(null);
        return;
      }

      console.log('useComparison: SUCCESS! Setting comparison data');
      setComparisonData({
        comparison,
        comparisonAGP,
        prevStart,
        prevEnd,
      });

    } catch (err) {
      console.error('Comparison calculation failed:', err);
      setComparisonData(null);
    }
  }, [csvData, startDate, endDate, dateRange]);

  return comparisonData;
}

/**
 * Helper function to check if comparison is available
 * (Can be used for UI logic without triggering calculation)
 */
export function canCompare(startDate, endDate, dateRange) {
  if (!startDate || !endDate || !dateRange) {
    return false;
  }

  const currentPeriodDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
  const isPresetPeriod = [14, 30].includes(currentPeriodDays);
  
  if (!isPresetPeriod) {
    return false;
  }

  const prevEnd = new Date(startDate);
  prevEnd.setDate(prevEnd.getDate() - 1);
  
  const prevStart = new Date(prevEnd);
  prevStart.setDate(prevStart.getDate() - currentPeriodDays + 1);

  return prevStart >= dateRange.min;
}

┌────────────────────────────────────────────────────────┐
│ FILE: src/components/AGPGenerator.jsx
└────────────────────────────────────────────────────────┘

import React, { useState, useEffect } from 'react';
import { Activity, Download, ChevronDown, AlertCircle } from 'lucide-react';

// Custom hooks
import { useCSVData } from '../hooks/useCSVData';
import { useMetrics } from '../hooks/useMetrics';
import { useComparison } from '../hooks/useComparison';

// Core utilities
import { parseProTime } from '../core/parsers';
import { downloadHTML } from '../core/html-exporter';

// UI Components
import FileUpload from './FileUpload';
import PeriodSelector from './PeriodSelector';
import MetricsDisplay from './MetricsDisplay';
import AGPChart from './AGPChart';
import ComparisonView from './ComparisonView';
import DayNightSplit from './DayNightSplit';
import WorkdaySplit from './WorkdaySplit';

/**
 * AGPGenerator - Main application container
 * 
 * Orchestrates the entire AGP+ application:
 * - CSV data loading and parsing
 * - ProTime workday data import
 * - Period selection and date management
 * - Metrics calculation coordination
 * - Component composition and data flow
 * 
 * @version 2.1.0
 */
export default function AGPGenerator() {
  // ============================================
  // HOOKS: Data Management
  // ============================================
  
  const { csvData, dateRange, loadCSV, error: csvError } = useCSVData();

  // ============================================
  // STATE: Period Selection
  // ============================================
  
  const [startDate, setStartDate] = useState(null);
  const [endDate, setEndDate] = useState(null);

  // ============================================
  // STATE: Optional Features
  // ============================================
  
  const [workdays, setWorkdays] = useState(null); // Set of workday date strings
  const [dayNightEnabled, setDayNightEnabled] = useState(false);
  const [dataImportExpanded, setDataImportExpanded] = useState(true); // Collapsible data import

  // ============================================
  // CALCULATED DATA: Metrics & Comparison
  // ============================================
  
  // Calculate metrics for current period
  const metricsResult = useMetrics(csvData, startDate, endDate, workdays);
  
  // Auto-calculate comparison for preset periods
  const comparisonData = useComparison(csvData, startDate, endDate, dateRange);

  // ============================================
  // EVENT HANDLERS: File Upload
  // ============================================

  /**
   * Auto-select last 14 days (or full range) when CSV is loaded
   * Keep import section OPEN so user can add ProTime
   */
  useEffect(() => {
    if (csvData && dateRange && !startDate && !endDate) {
      const end = new Date(dateRange.max);
      const start = new Date(end);
      start.setDate(start.getDate() - 13); // 14 days = today - 13 days
      
      // If data range is shorter than 14 days, use full range
      const actualStart = start < dateRange.min ? dateRange.min : start;
      
      setStartDate(actualStart);
      setEndDate(end);
      // NOTE: Import stays OPEN - no auto-collapse here
    }
  }, [csvData, dateRange, startDate, endDate]);

  /**
   * Handle CSV file upload
   */
  const handleCSVLoad = (text) => {
    loadCSV(text);
    
    // Reset period selection when new CSV is loaded
    setStartDate(null);
    setEndDate(null);
  };

  /**
   * Handle ProTime data import (PDF text or JSON)
   */
  const handleProTimeLoad = (text) => {
    try {
      const workdayDates = parseProTime(text);
      
      if (!workdayDates || workdayDates.length === 0) {
        console.error('No workdays found in ProTime data');
        return;
      }

      // Convert array to Set for fast lookups
      const workdaySet = new Set(workdayDates);
      setWorkdays(workdaySet);
      
    } catch (err) {
      console.error('ProTime parsing failed:', err);
    }
  };

  // ============================================
  // EVENT HANDLERS: Period Selection
  // ============================================

  /**
   * Handle period selection change
   * Collapse import section when user actively changes period
   */
  const handlePeriodChange = (newStartDate, newEndDate) => {
    setStartDate(newStartDate);
    setEndDate(newEndDate);
    
    // User is actively choosing a period = ready to analyze
    // Collapse import section to maximize space for metrics
    setDataImportExpanded(false);
  };

  /**
   * Handle day/night toggle
   */
  const handleDayNightToggle = () => {
    setDayNightEnabled(!dayNightEnabled);
  };

  /**
   * Handle HTML export
   */
  const handleExportHTML = () => {
    if (!metricsResult || !startDate || !endDate) return;
    
    // Format dates to YYYY/MM/DD
    const formatDate = (date) => {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}/${month}/${day}`;
    };
    
    downloadHTML({
      metrics: metricsResult.metrics,
      agpData: metricsResult.agp,
      events: metricsResult.events,
      startDate: formatDate(startDate),
      endDate: formatDate(endDate),
      // ALWAYS include day/night metrics in export (independent of UI toggle)
      dayNightMetrics: {
        day: metricsResult.dayMetrics,
        night: metricsResult.nightMetrics
      },
      workdaySplit: workdays && metricsResult.workdayMetrics && metricsResult.restdayMetrics ? {
        workday: metricsResult.workdayMetrics,
        restday: metricsResult.restdayMetrics,
        workdayCount: metricsResult.workdayMetrics.days,
        restdayCount: metricsResult.restdayMetrics.days
      } : null,
      comparison: comparisonData ? {
        current: metricsResult.metrics,
        previous: comparisonData.comparison,
        comparisonAGP: comparisonData.comparisonAGP,
        prevStart: formatDate(new Date(comparisonData.prevStart)),
        prevEnd: formatDate(new Date(comparisonData.prevEnd))
      } : null
    });
  };

  // ============================================
  // RENDER: Main UI
  // ============================================

  return (
    <div className="min-h-screen" style={{ background: 'var(--bg-primary)', color: 'var(--text-primary)' }}>
      <div className="app-container">
        
        {/* Header */}
        <header className="section">
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-4">
              <Activity className="w-8 h-8" style={{ color: 'var(--text-primary)' }} />
              <div>
                <h1 style={{ letterSpacing: '0.1em', fontWeight: 700, marginBottom: '0.25rem' }}>
                  AGP+ V2.1
                </h1>
                {/* Active Period Display */}
                {startDate && endDate && (
                  <p style={{ 
                    fontSize: '0.875rem', 
                    color: 'var(--color-green)',
                    fontWeight: 600,
                    letterSpacing: '0.05em',
                    fontFamily: 'monospace'
                  }}>
                    {startDate.toLocaleDateString('nl-NL', { day: '2-digit', month: '2-digit', year: 'numeric' })}
                    {' → '}
                    {endDate.toLocaleDateString('nl-NL', { day: '2-digit', month: '2-digit', year: 'numeric' })}
                    <span style={{ 
                      marginLeft: '0.5rem', 
                      color: 'var(--text-secondary)',
                      fontWeight: 400
                    }}>
                      ({Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1} dagen)
                    </span>
                  </p>
                )}
              </div>
            </div>
          </div>
          <p style={{ 
            fontSize: '0.875rem', 
            color: 'var(--text-secondary)', 
            letterSpacing: '0.05em',
            textTransform: 'uppercase'
          }}>
            Ambulatory Glucose Profile Generator
          </p>
        </header>

        {/* Top Controls Row: Import | Export | Period - All side by side */}
        <section className="section">
          {/* Row 1: 3-column grid - always horizontal */}
          <div style={{ 
            display: 'grid', 
            gridTemplateColumns: 'auto auto 1fr',
            gap: '1rem',
            alignItems: 'center',
            marginBottom: '1rem'
          }}>
            
            {/* 1. Data Import Button - Collapsible trigger */}
            <button
              onClick={() => setDataImportExpanded(!dataImportExpanded)}
              className="flex items-center justify-between rounded"
              style={{
                background: 'var(--bg-secondary)',
                border: '2px solid var(--border-primary)',
                cursor: 'pointer',
                transition: 'all 0.2s',
                padding: '0.75rem 1rem',
                minWidth: '140px'
              }}
            >
              <div className="flex items-center gap-3">
                <div style={{
                  width: '8px',
                  height: '8px',
                  borderRadius: '50%',
                  background: csvData ? 'var(--color-green)' : 'var(--color-gray)',
                  transition: 'all 0.2s'
                }} />
                <h2 style={{ 
                  fontSize: '0.875rem',
                  fontWeight: 700, 
                  letterSpacing: '0.1em',
                  textTransform: 'uppercase'
                }}>
                  Import
                </h2>
                {csvData && !dataImportExpanded && (
                  <span style={{ 
                    fontSize: '0.75rem', 
                    color: 'var(--text-secondary)',
                    letterSpacing: '0.05em'
                  }}>
                    ✓
                  </span>
                )}
              </div>
              <ChevronDown 
                className="w-5 h-5 ml-2"
                style={{
                  transform: dataImportExpanded ? 'rotate(0deg)' : 'rotate(-90deg)',
                  transition: 'transform 0.2s',
                  color: 'var(--text-secondary)'
                }}
              />
            </button>

            {/* 2. Export Button - Only when data available */}
            {metricsResult && startDate && endDate ? (
              <button
                onClick={handleExportHTML}
                className="btn btn-primary flex items-center gap-2"
                style={{
                  whiteSpace: 'nowrap'
                }}
              >
                <Download className="w-4 h-4" />
                Export
              </button>
            ) : <div />}

            {/* 3. Period Selector - Takes remaining space */}
            {csvData && dateRange ? (
              <PeriodSelector
                availableDates={dateRange}
                startDate={startDate}
                endDate={endDate}
                onChange={handlePeriodChange}
              />
            ) : <div />}
            
          </div>

          {/* Row 2: Expanded Import Content - full width below */}
          {dataImportExpanded && (
            <div className="mb-4" style={{ 
              background: 'var(--bg-secondary)',
              border: '2px solid var(--border-primary)',
              borderRadius: '4px',
              padding: '1rem'
            }}>
              <FileUpload
                onCSVLoad={handleCSVLoad}
                onProTimeLoad={handleProTimeLoad}
                csvLoaded={!!csvData}
                proTimeLoaded={!!workdays}
              />
              
              {csvError && (
                <div className="card mt-4" style={{ 
                  background: 'rgba(220, 38, 38, 0.1)', 
                  color: 'var(--color-red)',
                  border: '2px solid var(--color-red)',
                  padding: '1rem'
                }}>
                  <div className="flex items-start gap-3">
                    <AlertCircle className="w-5 h-5 flex-shrink-0 mt-0.5" style={{ color: 'var(--color-red)' }} />
                    <div>
                      <p style={{ fontSize: '0.875rem', fontWeight: 700, marginBottom: '0.5rem' }}>
                        CSV Import Error
                      </p>
                      <p style={{ fontSize: '0.875rem', lineHeight: '1.5' }}>
                        {csvError}
                      </p>
                      <p style={{ fontSize: '0.75rem', marginTop: '0.5rem', opacity: 0.8 }}>
                        Please ensure you're uploading a valid CareLink CSV export.
                      </p>
                    </div>
                  </div>
                </div>
              )}
            </div>
          )}
        </section>

        {/* Main Content - Only show when CSV loaded and period selected */}
        {csvData && dateRange && startDate && endDate && metricsResult && (
          <>
                {/* 1. AGP CHART - Visual Overview First */}
                <section className="section">
                  <AGPChart
                    agpData={metricsResult.agp}
                    events={metricsResult.events}
                    metrics={metricsResult.metrics}
                    comparison={comparisonData?.comparisonAGP || null}
                  />
                </section>

                {/* 2. HERO METRICS - TIR, Mean, CV, GMI + All Secondary */}
                <section className="section">
                  <MetricsDisplay
                    metrics={metricsResult.metrics}
                    startDate={startDate}
                    endDate={endDate}
                  />
                </section>

                {/* 3. DAY/NIGHT SPLIT */}
                <section className="section">
                  <DayNightSplit
                    dayMetrics={metricsResult.dayMetrics}
                    nightMetrics={metricsResult.nightMetrics}
                    enabled={dayNightEnabled}
                    onToggle={handleDayNightToggle}
                  />
                </section>

                {/* 4. WORKDAY SPLIT - Only show when ProTime loaded */}
                {workdays && metricsResult.workdayMetrics && metricsResult.restdayMetrics && (
                  <section className="section">
                    <WorkdaySplit
                      workdayMetrics={metricsResult.workdayMetrics}
                      restdayMetrics={metricsResult.restdayMetrics}
                      workdays={workdays}
                      startDate={startDate}
                      endDate={endDate}
                    />
                  </section>
                )}

                {/* 5. PERIOD COMPARISON - Last */}
                {comparisonData && (
                  <section className="section">
                    <ComparisonView
                      currentMetrics={metricsResult.metrics}
                      previousMetrics={comparisonData.comparison}
                      startDate={startDate}
                      endDate={endDate}
                      prevStart={comparisonData.prevStart}
                      prevEnd={comparisonData.prevEnd}
                    />
                  </section>
                )}
              </>
        )}

        {/* Footer */}
        <footer className="mt-16 pt-8 border-t border-gray-800 text-center text-sm text-gray-500">
          <p>
            AGP+ v2.1 | Built for Medtronic CareLink CSV exports
          </p>
          <p className="mt-2">
            Following{' '}
            <a 
              href="https://diabetesjournals.org/care/issue/48/Supplement_1"
              target="_blank"
              rel="noopener noreferrer"
              className="text-blue-400 hover:text-blue-300 underline"
            >
              ADA Standards of Care in Diabetes—2025
            </a>
          </p>
        </footer>
      </div>
    </div>
  );
}

/**
 * EmptyCSVState - Message shown when no CSV is loaded
 */
function EmptyCSVState() {
  return (
    <div className="text-center py-16">
      <div className="max-w-md mx-auto">
        <div className="mb-6">
          <Activity className="w-16 h-16 text-gray-600 mx-auto" />
        </div>
        
        <h2 className="text-2xl font-semibold text-gray-300 mb-4">
          Welcome to AGP+ v2.1
        </h2>
        
        <p className="text-gray-400 mb-6">
          Get started by uploading your Medtronic CareLink CSV export above.
        </p>

        <div className="bg-gray-800 border border-gray-700 rounded-lg p-6 text-left">
          <h3 className="font-semibold text-gray-200 mb-3">
            How to export from CareLink:
          </h3>
          <ol className="text-sm text-gray-400 space-y-2 list-decimal list-inside">
            <li>Log in to CareLink at carelink.minimed.eu</li>
            <li>Go to "Reports" → "Device Data"</li>
            <li>Select date range (minimum 14 days recommended)</li>
            <li>Click "Export" → "CSV"</li>
            <li>Upload the downloaded file above</li>
          </ol>
        </div>

        <div className="mt-6 bg-blue-900/20 border border-blue-700 rounded-lg p-4 text-left">
          <p className="text-sm text-blue-300">
            <strong>💡 Tip:</strong> For best results, export at least 14 days of data. 
            The tool will automatically compare periods if you export 30 or 90 days.
          </p>
        </div>
      </div>
    </div>
  );
}

/**
 * EmptyPeriodState - Message shown when CSV loaded but no period selected
 */
function EmptyPeriodState() {
  return (
    <div className="text-center py-12">
      <div className="max-w-md mx-auto">
        <h3 className="text-xl font-semibold text-gray-300 mb-3">
          Select an Analysis Period
        </h3>
        
        <p className="text-gray-400 mb-4">
          Choose a time period above to view your glucose metrics and AGP analysis.
        </p>

        <div className="bg-gray-800 border border-gray-700 rounded-lg p-4 text-left">
          <p className="text-sm text-gray-400">
            <strong className="text-gray-300">Available options:</strong>
          </p>
          <ul className="text-sm text-gray-400 mt-2 space-y-1 list-disc list-inside">
            <li><strong>14 days:</strong> Minimum recommended period</li>
            <li><strong>30 days:</strong> Standard monthly analysis</li>
            <li><strong>90 days:</strong> Quarterly review</li>
            <li><strong>Custom:</strong> Any date range within your data</li>
          </ul>
        </div>

        <div className="mt-4 bg-blue-900/20 border border-blue-700 rounded-lg p-3">
          <p className="text-xs text-blue-300">
            💡 Selecting 14, 30, or 90 days will automatically enable period comparison 
            if you have enough historical data.
          </p>
        </div>
      </div>
    </div>
  );
}

┌────────────────────────────────────────────────────────┐
│ FILE: src/components/FileUpload.jsx
└────────────────────────────────────────────────────────┘

import React, { useState, useRef } from 'react';
import { Upload, FileText, Calendar, X, AlertCircle } from 'lucide-react';

/**
 * FileUpload - Interactive file upload component
 * 
 * Provides UI for uploading:
 * 1. Medtronic CareLink CSV export
 * 2. ProTime workday data (PDF text or JSON)
 * 
 * @param {Function} props.onCSVLoad - Callback when CSV is loaded: (text) => void
 * @param {Function} props.onProTimeLoad - Callback when ProTime data is loaded: (text) => void
 * @param {boolean} props.csvLoaded - Whether CSV has been loaded
 * @param {boolean} props.proTimeLoaded - Whether ProTime has been loaded
 * 
 * @version 2.1.0
 */
export default function FileUpload({ 
  onCSVLoad, 
  onProTimeLoad, 
  csvLoaded = false,
  proTimeLoaded = false 
}) {
  const [isProTimeModalOpen, setIsProTimeModalOpen] = useState(false);
  const [error, setError] = useState(null);

  const handleCSVUpload = async (event) => {
    const file = event.target.files?.[0];
    if (!file) return;

    setError(null);

    // Validate file type
    if (!file.name.endsWith('.csv')) {
      setError('Please upload a CSV file');
      return;
    }

    try {
      const text = await file.text();
      
      // Basic validation: check for expected CSV structure
      if (!text.includes('YYYY/MM/DD') && !text.includes('Sensor Glucose')) {
        setError('This does not appear to be a Medtronic CareLink CSV file');
        return;
      }

      onCSVLoad(text);
    } catch (err) {
      setError(`Failed to read CSV file: ${err.message}`);
    }

    // Reset input so same file can be uploaded again
    event.target.value = '';
  };

  return (
    <div className="space-y-4">
      {/* Header */}
      <div className="flex items-center gap-2">
        <Upload className="w-5 h-5 text-gray-400" />
        <h3 className="text-lg font-semibold text-gray-100">Data Import</h3>
      </div>

      {/* Upload Buttons */}
      <div className="flex flex-wrap gap-3">
        {/* CSV Upload Button */}
        <CSVUploadButton 
          onUpload={handleCSVUpload}
          isLoaded={csvLoaded}
        />

        {/* ProTime Import Button */}
        <ProTimeButton 
          onClick={() => setIsProTimeModalOpen(true)}
          isLoaded={proTimeLoaded}
        />
      </div>

      {/* Error Message */}
      {error && (
        <div className="bg-red-900/20 border border-red-700 rounded-lg p-3 flex items-start gap-2">
          <AlertCircle className="w-5 h-5 text-red-400 flex-shrink-0 mt-0.5" />
          <div className="flex-1">
            <p className="text-sm text-red-300">{error}</p>
          </div>
          <button
            onClick={() => setError(null)}
            className="text-red-400 hover:text-red-300"
          >
            <X className="w-4 h-4" />
          </button>
        </div>
      )}

      {/* ProTime Modal */}
      {isProTimeModalOpen && (
        <ProTimeModal
          onClose={() => setIsProTimeModalOpen(false)}
          onLoad={onProTimeLoad}
          setError={setError}
        />
      )}
    </div>
  );
}

/**
 * CSVUploadButton - Button for CSV file upload
 */
function CSVUploadButton({ onUpload, isLoaded }) {
  const fileInputRef = useRef(null);

  return (
    <>
      <input
        ref={fileInputRef}
        type="file"
        accept=".csv"
        onChange={onUpload}
        className="hidden"
      />
      
      <button
        onClick={() => fileInputRef.current?.click()}
        className={`
          btn flex items-center gap-2
          ${isLoaded 
            ? 'btn-secondary border-green-600 text-green-400' 
            : 'btn-primary'
          }
        `}
      >
        <FileText className="w-4 h-4" />
        {isLoaded ? 'CSV Loaded ✓' : 'Upload CSV'}
      </button>
    </>
  );
}

/**
 * ProTimeButton - Button to open ProTime import modal
 */
function ProTimeButton({ onClick, isLoaded }) {
  return (
    <button
      onClick={onClick}
      className={`
        btn flex items-center gap-2
        ${isLoaded 
          ? 'btn-secondary border-green-600 text-green-400' 
          : 'btn-secondary'
        }
      `}
    >
      <Calendar className="w-4 h-4" />
      {isLoaded ? 'ProTime Loaded ✓' : 'Import ProTime (Optional)'}
    </button>
  );
}

/**
 * ProTimeModal - Modal for ProTime data import (PDF upload, PDF text, or JSON)
 */
function ProTimeModal({ onClose, onLoad, setError }) {
  const [activeTab, setActiveTab] = useState('pdf-upload'); // 'pdf-upload', 'pdf-text', or 'json'
  const [pdfText, setPdfText] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const pdfFileInputRef = useRef(null);
  const jsonFileInputRef = useRef(null);

  const handlePDFUpload = async (event) => {
    const files = Array.from(event.target.files || []);
    if (files.length === 0) return;

    // Validate all files are PDFs
    const nonPdfFiles = files.filter(f => !f.name.endsWith('.pdf'));
    if (nonPdfFiles.length > 0) {
      setError('Please upload only PDF files');
      return;
    }

    setIsProcessing(true);
    setError(null);

    try {
      // Import PDF parser
      const { extractTextFromPDF, extractTextFromMultiplePDFs } = await import('../utils/pdfParser');
      
      // Extract text from PDFs
      let extractedText;
      if (files.length === 1) {
        extractedText = await extractTextFromPDF(files[0]);
      } else {
        extractedText = await extractTextFromMultiplePDFs(files);
      }

      // Validate extracted text has ProTime content
      if (!extractedText.includes('Datum') && !extractedText.includes('Week')) {
        setError('PDF does not appear to contain ProTime timecard data');
        setIsProcessing(false);
        return;
      }

      onLoad(extractedText);
      onClose();
    } catch (err) {
      console.error('PDF processing error:', err);
      setError(`Failed to process PDF: ${err.message}`);
      setIsProcessing(false);
    }

    // Reset input
    event.target.value = '';
  };

  const handlePDFTextSubmit = () => {
    if (!pdfText.trim()) {
      setError('Please paste ProTime PDF text');
      return;
    }

    onLoad(pdfText);
    onClose();
  };

  const handleJSONUpload = async (event) => {
    const file = event.target.files?.[0];
    if (!file) return;

    if (!file.name.endsWith('.json')) {
      setError('Please upload a JSON file');
      return;
    }

    try {
      const text = await file.text();
      const data = JSON.parse(text);

      // Validate JSON structure - accept multiple formats:
      // 1. Direct array: ["2025/10/01", ...]
      // 2. Object with workdays array: {workdays: ["2025/10/01", ...]}
      // 3. Object with workdays object array: {workdays: [{date: "2025/10/01", is_workday: true}, ...]}
      
      let isValid = false;
      
      if (Array.isArray(data) && data.length > 0) {
        isValid = true;
      } else if (data && data.workdays && Array.isArray(data.workdays) && data.workdays.length > 0) {
        isValid = true;
      }
      
      if (!isValid) {
        setError('Invalid ProTime JSON format. Expected array of dates or object with workdays property.');
        return;
      }

      onLoad(JSON.stringify(data));
      onClose();
    } catch (err) {
      setError(`Failed to read JSON file: ${err.message}`);
    }

    // Reset input
    event.target.value = '';
  };

  return (
    <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
      <div className="bg-gray-800 border border-gray-700 rounded-lg max-w-2xl w-full max-h-[90vh] overflow-hidden flex flex-col">
        {/* Modal Header */}
        <div className="flex items-center justify-between p-4 border-b border-gray-700">
          <h3 className="text-lg font-semibold text-gray-100">
            Import ProTime Data
          </h3>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-300"
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* Tabs */}
        <div className="flex border-b border-gray-700">
          <button
            onClick={() => setActiveTab('pdf-upload')}
            className={`
              flex-1 px-4 py-3 text-sm font-medium transition-colors
              ${activeTab === 'pdf-upload'
                ? 'bg-gray-700 text-blue-400 border-b-2 border-blue-400'
                : 'text-gray-400 hover:text-gray-300'
              }
            `}
          >
            📄 PDF Upload
          </button>
          <button
            onClick={() => setActiveTab('pdf-text')}
            className={`
              flex-1 px-4 py-3 text-sm font-medium transition-colors
              ${activeTab === 'pdf-text'
                ? 'bg-gray-700 text-blue-400 border-b-2 border-blue-400'
                : 'text-gray-400 hover:text-gray-300'
              }
            `}
          >
            📋 PDF Text
          </button>
          <button
            onClick={() => setActiveTab('json')}
            className={`
              flex-1 px-4 py-3 text-sm font-medium transition-colors
              ${activeTab === 'json'
                ? 'bg-gray-700 text-blue-400 border-b-2 border-blue-400'
                : 'text-gray-400 hover:text-gray-300'
              }
            `}
          >
            📊 JSON File
          </button>
        </div>

        {/* Tab Content */}
        <div className="flex-1 overflow-y-auto p-4">
          {activeTab === 'pdf-upload' ? (
            <PDFUploadTab 
              fileInputRef={pdfFileInputRef}
              onUpload={handlePDFUpload}
              isProcessing={isProcessing}
            />
          ) : activeTab === 'pdf-text' ? (
            <PDFTextTab 
              pdfText={pdfText}
              setPdfText={setPdfText}
              onSubmit={handlePDFTextSubmit}
            />
          ) : (
            <JSONFileTab 
              fileInputRef={jsonFileInputRef}
              onUpload={handleJSONUpload}
            />
          )}
        </div>
      </div>
    </div>
  );
}

/**
 * PDFUploadTab - Tab for uploading ProTime PDF files directly
 */
function PDFUploadTab({ fileInputRef, onUpload, isProcessing }) {
  return (
    <div className="space-y-4">
      <div>
        <label className="block text-sm font-medium text-gray-300 mb-2">
          Upload ProTime PDF(s)
        </label>
        <p className="text-xs text-gray-500 mb-3">
          Select one or more ProTime PDF exports. Multiple PDFs will be combined automatically.
        </p>
        
        <input
          ref={fileInputRef}
          type="file"
          accept=".pdf"
          multiple
          onChange={onUpload}
          disabled={isProcessing}
          className="hidden"
        />
        
        <button
          onClick={() => fileInputRef.current?.click()}
          disabled={isProcessing}
          className="w-full px-4 py-8 border-2 border-dashed border-gray-600 rounded-lg
                     bg-gray-900/50 hover:bg-gray-900 hover:border-blue-500
                     transition-colors text-gray-400 hover:text-gray-300
                     disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <div className="flex flex-col items-center gap-2">
            {isProcessing ? (
              <>
                <div className="w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
                <span className="text-sm">Processing PDF...</span>
              </>
            ) : (
              <>
                <Upload className="w-8 h-8" />
                <span className="text-sm font-medium">Click to select PDF file(s)</span>
                <span className="text-xs text-gray-500">or drag and drop here</span>
              </>
            )}
          </div>
        </button>
      </div>

      <div className="bg-green-900/20 border border-green-700 rounded-lg p-3 space-y-2">
        <p className="text-xs text-green-300">
          <strong>✨ Easy way:</strong> Just upload your ProTime PDF(s)!
        </p>
        <ul className="text-xs text-green-300 list-disc list-inside space-y-1">
          <li>Automatic text extraction</li>
          <li>Multiple PDFs supported (for multi-month analysis)</li>
          <li>No copy-paste needed</li>
        </ul>
      </div>

      <div className="bg-blue-900/20 border border-blue-700 rounded-lg p-3">
        <p className="text-xs text-blue-300">
          <strong>Tip:</strong> To analyze multiple months, select all ProTime PDFs at once 
          (hold Cmd/Ctrl while clicking files).
        </p>
      </div>
    </div>
  );
}

/**
 * PDFTextTab - Tab for pasting ProTime PDF text
 */
function PDFTextTab({ pdfText, setPdfText, onSubmit }) {
  return (
    <div className="space-y-4">
      <div>
        <label className="block text-sm font-medium text-gray-300 mb-2">
          Paste ProTime PDF text
        </label>
        <p className="text-xs text-gray-500 mb-3">
          Copy the entire content from your ProTime PDF export and paste it here.
        </p>
        <textarea
          value={pdfText}
          onChange={(e) => setPdfText(e.target.value)}
          placeholder="Paste ProTime PDF text here..."
          className="w-full h-64 px-3 py-2 bg-gray-900 border border-gray-600 rounded-md 
                     text-gray-100 font-mono text-sm
                     focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent
                     placeholder-gray-600"
        />
      </div>

      <div className="bg-blue-900/20 border border-blue-700 rounded-lg p-3">
        <p className="text-xs text-blue-300">
          <strong>How to export from ProTime:</strong><br/>
          1. Open your ProTime PDF<br/>
          2. Select all text (Cmd+A or Ctrl+A)<br/>
          3. Copy (Cmd+C or Ctrl+C)<br/>
          4. Paste here (Cmd+V or Ctrl+V)
        </p>
      </div>

      <button
        onClick={onSubmit}
        disabled={!pdfText.trim()}
        className="btn btn-primary w-full"
      >
        Import PDF Text
      </button>
    </div>
  );
}

/**
 * JSONFileTab - Tab for uploading ProTime JSON file
 */
function JSONFileTab({ fileInputRef, onUpload }) {
  return (
    <div className="space-y-4">
      <input
        ref={fileInputRef}
        type="file"
        accept=".json"
        onChange={onUpload}
        className="hidden"
      />

      <div className="text-center py-12">
        <div className="mb-4">
          <FileText className="w-16 h-16 text-gray-600 mx-auto" />
        </div>
        
        <h4 className="text-lg font-medium text-gray-300 mb-2">
          Upload ProTime JSON
        </h4>
        
        <p className="text-sm text-gray-500 mb-6">
          Select a previously exported ProTime JSON file
        </p>

        <button
          onClick={() => fileInputRef.current?.click()}
          className="btn btn-primary"
        >
          <Upload className="w-4 h-4 mr-2" />
          Select JSON File
        </button>
      </div>

      <div className="bg-gray-900/50 border border-gray-700 rounded-lg p-4">
        <h5 className="text-sm font-medium text-gray-300 mb-2">
          Expected JSON format:
        </h5>
        <pre className="text-xs text-gray-500 font-mono overflow-x-auto">
{`[
  "2025-01-15",
  "2025-01-16",
  "2025-01-17",
  ...
]`}
        </pre>
        <p className="text-xs text-gray-500 mt-2">
          Array of workday dates in YYYY-MM-DD format
        </p>
      </div>

      <div className="bg-blue-900/20 border border-blue-700 rounded-lg p-3">
        <p className="text-xs text-blue-300">
          <strong>First time using ProTime data?</strong><br/>
          Use the "PDF Text" tab instead. You can export to JSON later from the app.
        </p>
      </div>
    </div>
  );
}

┌────────────────────────────────────────────────────────┐
│ FILE: src/components/PeriodSelector.jsx
└────────────────────────────────────────────────────────┘

import React from 'react';
import { Calendar } from 'lucide-react';

/**
 * PeriodSelector - Date range selection component
 * 
 * Provides preset period buttons (14d, 30d, 90d) and custom date inputs
 * for flexible analysis period selection.
 * 
 * @param {Date} props.startDate - Currently selected start date
 * @param {Date} props.endDate - Currently selected end date
 * @param {Object} props.availableDates - { min: Date, max: Date } available date range from CSV
 * @param {Function} props.onChange - Callback when dates change: (startDate, endDate) => void
 * 
 * @version 2.1.0
 */
export default function PeriodSelector({ startDate, endDate, availableDates, onChange }) {
  if (!availableDates) {
    return null;
  }

  const handlePresetClick = (days) => {
    const end = new Date(availableDates.max);
    const start = new Date(end);
    start.setDate(start.getDate() - days + 1);
    
    // Ensure start is not before available data
    const actualStart = start < availableDates.min ? availableDates.min : start;
    
    onChange(actualStart, end);
  };

  const handleCustomStartChange = (e) => {
    if (!endDate) return; // Need endDate to validate
    const newStart = new Date(e.target.value);
    if (newStart <= endDate && newStart >= availableDates.min) {
      onChange(newStart, endDate);
    }
  };

  const handleCustomEndChange = (e) => {
    if (!startDate) return; // Need startDate to validate
    const newEnd = new Date(e.target.value);
    if (newEnd >= startDate && newEnd <= availableDates.max) {
      onChange(startDate, newEnd);
    }
  };

  // Calculate current period length (only if both dates exist)
  const daysDiff = startDate && endDate 
    ? Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1
    : 0;

  // Format dates for input fields (YYYY-MM-DD)
  const formatDateForInput = (date) => {
    if (!date) return '';
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };

  // Format dates for display (DD-MM-YYYY)
  const formatDateForDisplay = (date) => {
    if (!date) return '';
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = date.getFullYear();
    return `${day}-${month}-${year}`;
  };

  return (
    <div className="flex items-center gap-2" style={{ flexWrap: 'nowrap' }}>
      {/* Preset Buttons - Inline */}
      <div className="flex gap-2" style={{ flexShrink: 0 }}>
        <PresetButton
          label="14d"
          days={14}
          onClick={() => handlePresetClick(14)}
          isActive={daysDiff === 14}
          isDisabled={false}
        />
        <PresetButton
          label="30d"
          days={30}
          onClick={() => handlePresetClick(30)}
          isActive={daysDiff === 30}
          isDisabled={false}
        />
        <PresetButton
          label="90d"
          days={90}
          onClick={() => handlePresetClick(90)}
          isActive={daysDiff === 90}
          isDisabled={false}
        />
      </div>

      {/* Custom Date Inputs - Inline */}
      <div className="flex gap-2 items-center">
        {/* Start Date */}
        <div className="flex items-center gap-2">
          <label className="text-xs text-gray-400 whitespace-nowrap">
            Start
          </label>
          <input
            type="date"
            value={formatDateForInput(startDate)}
            min={formatDateForInput(availableDates.min)}
            max={formatDateForInput(endDate)}
            onChange={handleCustomStartChange}
            className="px-2 py-1 bg-gray-700 border border-gray-600 rounded text-gray-100 text-sm
                       focus:outline-none focus:ring-1 focus:ring-blue-500"
          />
        </div>

        {/* End Date */}
        <div className="flex items-center gap-2">
          <label className="text-xs text-gray-400 whitespace-nowrap">
            End
          </label>
          <input
            type="date"
            value={formatDateForInput(endDate)}
            min={formatDateForInput(startDate)}
            max={formatDateForInput(availableDates.max)}
            onChange={handleCustomEndChange}
            className="px-2 py-1 bg-gray-700 border border-gray-600 rounded text-gray-100 text-sm
                       focus:outline-none focus:ring-1 focus:ring-blue-500"
          />
        </div>
        
        {/* Period Length Badge */}
        {daysDiff > 0 && (
          <div className="px-3 py-1 bg-gray-700 border border-gray-600 rounded text-xs text-gray-300">
            {daysDiff} {daysDiff === 1 ? 'dag' : 'dagen'}
          </div>
        )}
      </div>
    </div>
  );
}

/**
  );
}

/**
 * PresetButton - Reusable button component for preset periods
 */
function PresetButton({ label, days, onClick, isActive, isDisabled }) {
  return (
    <button
      onClick={onClick}
      disabled={isDisabled}
      className={`
        px-4 py-2 rounded-md font-medium text-sm transition-all
        ${isActive 
          ? 'bg-blue-600 text-white border-2 border-blue-400' 
          : 'bg-gray-700 text-gray-300 border-2 border-gray-600 hover:bg-gray-600 hover:border-gray-500'
        }
        ${isDisabled 
          ? 'opacity-50 cursor-not-allowed' 
          : 'cursor-pointer'
        }
        focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-900
      `}
    >
      {label}
    </button>
  );
}

┌────────────────────────────────────────────────────────┐
│ FILE: src/components/MetricsDisplay.jsx
└────────────────────────────────────────────────────────┘

import React from 'react';
import { TrendingUp, TrendingDown, Activity, Zap } from 'lucide-react';

/**
 * MetricsDisplay - Clinical Dashboard Layout
 * 
 * Hero Grid: 4 primary metrics (TIR 2x wide, Mean±SD, CV, GMI)
 * Secondary Grid: All other metrics with reduced visual weight
 * 
 * @version 2.1.2 CLINICAL HIERARCHY
 */
export default function MetricsDisplay({ metrics }) {
  if (!metrics) {
    return (
      <div className="card" style={{ textAlign: 'center', padding: '3rem' }}>
        <p style={{ color: 'var(--text-secondary)', letterSpacing: '0.05em', textTransform: 'uppercase' }}>
          No metrics available. Upload CSV data.
        </p>
      </div>
    );
  }

  const safeFormat = (val, decimals = 0) => {
    const num = Number(val);
    if (isNaN(num) || !isFinite(num)) return 'N/A';
    return num.toFixed(decimals);
  };

  // Helper to determine if metric is in target range
  const getStatus = (id, value) => {
    const v = Number(value);
    if (isNaN(v)) return 'neutral';
    
    switch(id) {
      case 'tir': return v >= 70 ? 'good' : v >= 50 ? 'warning' : 'danger';
      case 'tar': return v <= 25 ? 'good' : v <= 50 ? 'warning' : 'danger';
      case 'tbr': return v <= 4 ? 'good' : v <= 10 ? 'warning' : 'danger';
      case 'cv': return v <= 36 ? 'good' : v <= 50 ? 'warning' : 'danger';
      case 'gmi': return v < 7.0 ? 'good' : v < 8.0 ? 'warning' : 'danger';
      case 'mean': return (v >= 70 && v <= 180) ? 'good' : 'warning';
      default: return 'neutral';
    }
  };

  return (
    <>
      {/* HERO GRID - Primary Metrics (4 equal cards) */}
      <div style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fit, minmax(240px, 1fr))',
        gap: '1rem',
        marginBottom: '2rem'
      }}>
        
        {/* TIR */}
        <div 
          className="card-hero" 
          style={{ 
            padding: '2rem',
            minHeight: '180px',
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center'
          }}
        >
          <div style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', marginBottom: '1rem' }}>
            <Activity style={{ width: '24px', height: '24px', color: 'var(--text-inverse)' }} />
            <span style={{ 
              fontSize: '0.875rem', 
              fontWeight: 700, 
              letterSpacing: '0.1em',
              textTransform: 'uppercase'
            }}>
              Time in Range
            </span>
          </div>
          
          <div style={{ 
            fontSize: 'clamp(3rem, 8vw, 4.5rem)', 
            fontWeight: 700, 
            letterSpacing: '-0.02em',
            marginBottom: '0.5rem',
            lineHeight: 1
          }}>
            {safeFormat(metrics.tir, 1)}%
          </div>
          
          <div style={{ 
            fontSize: '0.75rem', 
            fontWeight: 600,
            letterSpacing: '0.05em',
            textTransform: 'uppercase',
            opacity: 0.8
          }}>
            Target ≥70% • 70-180 mg/dL
          </div>
        </div>

        {/* Mean ± SD */}
        <PrimaryMetricCard
          icon={Activity}
          label="Mean Glucose"
          value={safeFormat(metrics.mean, 0)}
          unit="mg/dL"
          subtitle={`± ${safeFormat(metrics.sd, 0)} SD`}
          status={getStatus('mean', metrics.mean)}
        />

        {/* CV */}
        <PrimaryMetricCard
          icon={Zap}
          label="CV"
          value={safeFormat(metrics.cv, 1)}
          unit="%"
          subtitle="Target ≤36%"
          status={getStatus('cv', metrics.cv)}
        />

        {/* GMI */}
        <PrimaryMetricCard
          icon={Activity}
          label="GMI"
          value={safeFormat(metrics.gmi, 1)}
          unit="%"
          subtitle={`~${safeFormat(metrics.gmi, 1)}% HbA1c`}
          status={getStatus('gmi', metrics.gmi)}
        />
      </div>

      {/* SECONDARY GRID - Detail Metrics (aligned grid layout) */}
      <div style={{ 
        display: 'grid',
        gridTemplateColumns: '200px 1fr 1fr',
        gap: '1rem',
        alignItems: 'stretch'
      }}>
        
        {/* Range Distribution */}
        <div style={{ 
          display: 'flex',
          alignItems: 'center',
          fontSize: '0.75rem', 
          fontWeight: 700, 
          letterSpacing: '0.15em', 
          textTransform: 'uppercase',
          color: 'var(--text-secondary)'
        }}>
          Range Distribution
        </div>
        <SecondaryMetricCard label="TAR >180" value={safeFormat(metrics.tar, 1)} unit="%" status={getStatus('tar', metrics.tar)} />
        <SecondaryMetricCard label="TBR <70" value={safeFormat(metrics.tbr, 1)} unit="%" status={getStatus('tbr', metrics.tbr)} />

        {/* Variability Metrics */}
        <div style={{ 
          display: 'flex',
          alignItems: 'center',
          fontSize: '0.75rem', 
          fontWeight: 700, 
          letterSpacing: '0.15em', 
          textTransform: 'uppercase',
          color: 'var(--text-secondary)'
        }}>
          Variability Metrics
        </div>
        <SecondaryMetricCard label="MAGE" value={safeFormat(metrics.mage, 0)} unit="mg/dL" subtitle="Glycemic excursions" />
        <SecondaryMetricCard label="MODD" value={safeFormat(metrics.modd, 0)} unit="mg/dL" subtitle="Day-to-day variability" />

        {/* Glucose Range */}
        <div style={{ 
          display: 'flex',
          alignItems: 'center',
          fontSize: '0.75rem', 
          fontWeight: 700, 
          letterSpacing: '0.15em', 
          textTransform: 'uppercase',
          color: 'var(--text-secondary)'
        }}>
          Glucose Range
        </div>
        <SecondaryMetricCard label="Minimum" value={safeFormat(metrics.min, 0)} unit="mg/dL" />
        <SecondaryMetricCard label="Maximum" value={safeFormat(metrics.max, 0)} unit="mg/dL" />

        {/* Analysis Period */}
        <div style={{ 
          display: 'flex',
          alignItems: 'center',
          fontSize: '0.75rem', 
          fontWeight: 700, 
          letterSpacing: '0.15em', 
          textTransform: 'uppercase',
          color: 'var(--text-secondary)'
        }}>
          Analysis Period
        </div>
        <SecondaryMetricCard label="Days Analyzed" value={safeFormat(metrics.days, 0)} unit="days" />
        <SecondaryMetricCard 
          label="CGM Readings" 
          value={metrics.readingCount != null ? metrics.readingCount.toLocaleString() : 'N/A'} 
          unit=""
          subtitle={
            metrics.readingCount != null && metrics.days != null
              ? `${safeFormat((metrics.readingCount / (metrics.days * 288)) * 100, 0)}% coverage`
              : ''
          }
        />
      </div>
    </>
  );
}

/**
 * PrimaryMetricCard - Hero Grid Metrics (Mean, CV, GMI)
 * Large text, high contrast, prominent display
 */
function PrimaryMetricCard({ icon: Icon, label, value, unit, subtitle, status = 'neutral' }) {
  const getStatusColor = () => {
    switch(status) {
      case 'good': return 'var(--text-primary)';
      case 'warning': return 'var(--color-yellow)';
      case 'danger': return 'var(--color-red)';
      default: return 'var(--text-primary)';
    }
  };

  return (
    <div 
      className="card"
      style={{
        padding: '1.5rem',
        minHeight: '180px',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'space-between'
      }}
    >
      {/* Icon + Label */}
      <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '1rem' }}>
        <Icon style={{ 
          width: '20px', 
          height: '20px',
          color: status === 'danger' ? 'var(--color-red)' : 
                 status === 'warning' ? 'var(--color-yellow)' : 
                 'var(--text-primary)'
        }} />
        <span style={{ 
          fontSize: '0.875rem',
          fontWeight: 700,
          letterSpacing: '0.1em',
          textTransform: 'uppercase',
          color: 'var(--text-secondary)'
        }}>
          {label}
        </span>
      </div>

      {/* Value */}
      <div>
        <div style={{ 
          fontSize: 'clamp(2.5rem, 5vw, 3.5rem)',
          fontWeight: 700,
          letterSpacing: '-0.02em',
          color: getStatusColor(),
          lineHeight: 1,
          marginBottom: '0.5rem',
          fontVariantNumeric: 'tabular-nums'
        }}>
          {value}
          <span style={{ fontSize: '1.5rem', marginLeft: '0.25rem', opacity: 0.7 }}>{unit}</span>
        </div>

        {/* Subtitle */}
        {subtitle && (
          <div style={{ 
            fontSize: '1rem',
            fontWeight: 600,
            color: '#d1d5db',
            marginTop: '0.25rem'
          }}>
            {subtitle}
          </div>
        )}
      </div>
    </div>
  );
}

/**
 * SecondaryMetricCard - Detail Grid Metrics
 * White-on-dark with proper contrast, grouped by category
 */
function SecondaryMetricCard({ label, value, unit, subtitle, status = 'neutral' }) {
  const getStatusColor = () => {
    switch(status) {
      case 'good': return '#10b981'; // green-500
      case 'warning': return '#f59e0b'; // amber-500
      case 'danger': return '#ef4444'; // red-500
      default: return '#f9fafb'; // gray-50 (white for good contrast)
    }
  };

  return (
    <div 
      style={{
        backgroundColor: '#111827', // gray-900
        color: 'white',
        padding: '1.25rem',
        borderRadius: '4px',
        border: '2px solid #1f2937' // gray-800
      }}
    >
      {/* Label */}
      <div style={{ 
        fontSize: '0.75rem',
        fontWeight: 700,
        letterSpacing: '0.1em',
        textTransform: 'uppercase',
        marginBottom: '0.75rem',
        color: '#9ca3af' // gray-400
      }}>
        {label}
      </div>

      {/* Value */}
      <div style={{ 
        fontSize: '2rem',
        fontWeight: 700,
        letterSpacing: '-0.01em',
        color: getStatusColor(),
        fontVariantNumeric: 'tabular-nums',
        lineHeight: 1
      }}>
        {value}
        {unit && <span style={{ fontSize: '1rem', marginLeft: '0.25rem', color: '#d1d5db' }}>{unit}</span>}
      </div>

      {/* Subtitle */}
      {subtitle && (
        <div style={{ 
          fontSize: '0.6875rem',
          fontWeight: 600,
          letterSpacing: '0.05em',
          marginTop: '0.5rem',
          color: '#6b7280', // gray-500
          textTransform: 'uppercase'
        }}>
          {subtitle}
        </div>
      )}
    </div>
  );
}

┌────────────────────────────────────────────────────────┐
│ FILE: src/components/AGPChart.jsx
└────────────────────────────────────────────────────────┘

import React, { useMemo } from 'react';
import { CONFIG } from '../core/metrics-engine.js';
import TIRBar from './TIRBar.jsx';
import HypoglycemiaEvents from './HypoglycemiaEvents.jsx';

/**
 * AGPChart - Ambulatory Glucose Profile SVG Visualization
 * 
 * Renders AGP curve with percentile bands (5th, 25th, 50th, 75th, 95th),
 * target lines, event markers, and optional comparison overlay.
 * 
 * @param {Array} props.agpData - Array[288] of AGP bins with percentiles
 * @param {Object} props.events - { hypoL1: [], hypoL2: [], hyper: [] } with minuteOfDay
 * @param {Object} props.comparison - Optional comparison AGP data
 * @param {number} props.width - SVG width (default: 900)
 * @param {number} props.height - SVG height (default: 400)
 * 
 * AGP Data Structure:
 * agpData[i] = {
 *   p5: number,   // 5th percentile
 *   p25: number,  // 25th percentile
 *   p50: number,  // 50th percentile (median)
 *   p75: number,  // 75th percentile
 *   p95: number,  // 95th percentile
 *   mean: number  // Mean glucose
 * }
 * 
 * @version 2.1.0
 */
export default function AGPChart({ 
  agpData, 
  events = { hypoL1: [], hypoL2: [], hyper: [] },
  comparison = null,
  metrics = null,
  width = 900, 
  height = 400 
}) {
  if (!agpData || agpData.length === 0) {
    return (
      <div className="card text-center py-12">
        <p className="text-gray-400">No AGP data available</p>
      </div>
    );
  }

  // Calculate chart dimensions
  const margin = { top: 20, right: 60, bottom: 40, left: 60 };
  const chartWidth = width - margin.left - margin.right;
  const chartHeight = height - margin.top - margin.bottom;

  // Scale functions
  const xScale = (minuteOfDay) => margin.left + (minuteOfDay / 1440) * chartWidth;
  const yScale = (glucose) => margin.top + chartHeight - ((glucose / CONFIG.GLUCOSE.MAX) * chartHeight);

  // Generate SVG paths using memo for performance
  const paths = useMemo(() => generatePaths(agpData, xScale, yScale), [agpData]);
  const comparisonPath = useMemo(() => 
    comparison ? generatePath(comparison, 'p50', xScale, yScale) : null,
    [comparison, xScale, yScale]
  );

  return (
    <div className="space-y-4">
      {/* Header */}
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-semibold text-gray-100">
          Ambulatory Glucose Profile (AGP)
        </h3>
        <div className="text-sm text-gray-400">
          24-hour glucose pattern
        </div>
      </div>

      {/* TIR Bar - only if metrics provided */}
      {metrics && <TIRBar metrics={metrics} />}

      {/* SVG Chart with Legend Overlay */}
      <div className="card bg-white border-gray-300 overflow-hidden" style={{ position: 'relative' }}>
        {/* Legend positioned absolute in top-right */}
        <ChartLegend hasComparison={!!comparison} />
        
        <svg width={width} height={height} className="w-full h-auto">
          {/* White background */}
          <rect x="0" y="0" width={width} height={height} fill="white" />
          
          {/* Grid lines */}
          <GridLines 
            margin={margin}
            chartWidth={chartWidth}
            chartHeight={chartHeight}
            yScale={yScale}
          />

          {/* Night end marker - vertical dashed line at 06:00 */}
          <line
            x1={xScale(6 * 60)}
            y1={margin.top}
            x2={xScale(6 * 60)}
            y2={margin.top + chartHeight}
            stroke="#666"
            strokeWidth="2"
            strokeDasharray="8,4"
            opacity="0.6"
          />

          {/* Target lines */}
          <TargetLines 
            margin={margin}
            chartWidth={chartWidth}
            yScale={yScale}
          />

          {/* Percentile bands (shaded areas) */}
          {/* 5-95th percentile band - light blue with 30% opacity */}
          <path
            d={paths.band_5_95}
            fill="#93c5fd"
            opacity="0.5"
          />
          
          {/* 25-75th percentile band - darker blue with 50% opacity */}
          <path
            d={paths.band_25_75}
            fill="#3b82f6"
            opacity="0.5"
          />

          {/* Median line (p50) - black DASHED */}
          <path
            d={paths.median}
            fill="none"
            stroke="#000000"
            strokeWidth="2"
            strokeDasharray="4,4"
            strokeLinecap="butt"
          />
          
          {/* Mean line - orange dashed */}
          <path
            d={paths.mean}
            fill="none"
            stroke="#fb923c"
            strokeWidth="2"
            strokeDasharray="3,3"
            strokeLinecap="butt"
          />

          {/* Comparison overlay (if present) - gray dashed thicker */}
          {comparisonPath && (
            <path
              d={comparisonPath}
              fill="none"
              stroke="#9ca3af"
              strokeWidth="2.5"
              strokeDasharray="6,4"
              opacity="0.9"
            />
          )}

          {/* Event markers */}
          <EventMarkers 
            events={events}
            xScale={xScale}
            yScale={yScale}
            chartHeight={chartHeight}
            margin={margin}
          />

          {/* Axes */}
          <XAxis 
            margin={margin}
            chartWidth={chartWidth}
            chartHeight={chartHeight}
          />
          <YAxis 
            margin={margin}
            chartHeight={chartHeight}
            yScale={yScale}
          />
        </svg>
      </div>

      {/* Hypoglycemia Events Warning Panel */}
      <HypoglycemiaEvents 
        events={events} 
        tbrPercent={metrics?.tbr}
      />
    </div>
  );
}

/**
 * Generate all AGP paths (memoized for performance)
 */
function generatePaths(agpData, xScale, yScale) {
  return {
    median: generatePath(agpData, 'p50', xScale, yScale),
    mean: generatePath(agpData, 'mean', xScale, yScale),
    band_5_95: generateBand(agpData, 'p95', 'p5', xScale, yScale),
    band_25_75: generateBand(agpData, 'p75', 'p25', xScale, yScale),
  };
}

/**
 * Generate SVG path for a percentile line
 */
function generatePath(agpData, percentile, xScale, yScale) {
  return agpData.map((d, i) => {
    const minuteOfDay = (i / CONFIG.AGP_BINS) * 1440;
    const x = xScale(minuteOfDay);
    const y = yScale(d[percentile]);
    return `${i === 0 ? 'M' : 'L'} ${x} ${y}`;
  }).join(' ');
}

/**
 * Generate SVG path for filled band between two percentiles
 */
function generateBand(agpData, topPercentile, bottomPercentile, xScale, yScale) {
  // Top path (left to right)
  const topPath = agpData.map((d, i) => {
    const minuteOfDay = (i / CONFIG.AGP_BINS) * 1440;
    const x = xScale(minuteOfDay);
    const y = yScale(d[topPercentile]);
    return `${x},${y}`;
  }).join(' L ');
  
  // Bottom path (right to left)
  const bottomPath = agpData.slice().reverse().map((d, i) => {
    const reverseIdx = CONFIG.AGP_BINS - 1 - i;
    const minuteOfDay = (reverseIdx / CONFIG.AGP_BINS) * 1440;
    const x = xScale(minuteOfDay);
    const y = yScale(d[bottomPercentile]);
    return `${x},${y}`;
  }).join(' L ');
  
  return `M ${topPath} L ${bottomPath} Z`;
}

/**
 * GridLines - Horizontal grid (BRUTALIST: black 1px)
 */
function GridLines({ margin, chartWidth, chartHeight, yScale }) {
  const gridValues = [0, 54, 70, 100, 140, 180, 250, 300, 400];
  
  return (
    <g className="grid">
      {gridValues.map((value) => (
        <line
          key={value}
          x1={margin.left}
          y1={yScale(value)}
          x2={margin.left + chartWidth}
          y2={yScale(value)}
          stroke="#000000"
          strokeWidth="1"
          opacity="0.2"
        />
      ))}
    </g>
  );
}

/**
 * TargetLines - Clinical targets (BRUTALIST: massive lines, red/yellow)
 */
function TargetLines({ margin, chartWidth, yScale }) {
  const targets = [
    { value: 54, color: '#c70000', width: 2, dash: '8,4' },    // Critical Low - Soviet red
    { value: 70, color: '#000000', width: 3, dash: 'none' },   // Low - Black
    { value: 180, color: '#000000', width: 3, dash: 'none' },  // High - Black
    { value: 250, color: '#c70000', width: 2, dash: '8,4' },   // Very High - Soviet red
  ];

  return (
    <g className="target-lines">
      {targets.map((target) => (
        <line
          key={target.value}
          x1={margin.left}
          y1={yScale(target.value)}
          x2={margin.left + chartWidth}
          y2={yScale(target.value)}
          stroke={target.color}
          strokeWidth={target.width}
          strokeDasharray={target.dash}
        />
      ))}
    </g>
  );
}

/**
 * EventMarkers - BRUTALIST event indicators (Soviet red/yellow)
 */
function EventMarkers({ events, xScale, yScale, chartHeight, margin }) {
  if (!events) return null;
  
  const hypoL2 = Array.isArray(events.hypoL2?.events) ? events.hypoL2.events : (Array.isArray(events.hypoL2) ? events.hypoL2 : []);
  const hypoL1 = Array.isArray(events.hypoL1?.events) ? events.hypoL1.events : (Array.isArray(events.hypoL1) ? events.hypoL1 : []);
  const hyper = Array.isArray(events.hyper?.events) ? events.hyper.events : (Array.isArray(events.hyper) ? events.hyper : []);
  
  return (
    <g className="event-markers">
      {/* Hypo L2 (critical <54) - Soviet Red X */}
      {hypoL2.map((event, i) => {
        const cx = xScale(event.minuteOfDay);
        const cy = yScale(event.startGlucose || 50);
        return (
          <g key={`hypoL2-${i}`}>
            <circle cx={cx} cy={cy} r="6" fill="#c70000" />
            <line x1={cx - 3} y1={cy - 3} x2={cx + 3} y2={cy + 3} stroke="#ffffff" strokeWidth="2" />
            <line x1={cx + 3} y1={cy - 3} x2={cx - 3} y2={cy + 3} stroke="#ffffff" strokeWidth="2" />
          </g>
        );
      })}

      {/* Hypo L1 (54-69) - Yellow Circle */}
      {hypoL1.map((event, i) => {
        const cx = xScale(event.minuteOfDay);
        const cy = yScale(event.startGlucose || 62);
        return (
          <circle
            key={`hypoL1-${i}`}
            cx={cx}
            cy={cy}
            r="5"
            fill="#f4e300"
            stroke="#000000"
            strokeWidth="1"
          />
        );
      })}

      {/* Hyperglycemia (>250) - Soviet Red Triangle */}
      {hyper.map((event, i) => {
        const cx = xScale(event.minuteOfDay);
        const cy = yScale(event.startGlucose || 280);
        const size = 7;
        return (
          <polygon
            key={`hyper-${i}`}
            points={`${cx},${cy - size} ${cx - size},${cy + size} ${cx + size},${cy + size}`}
            fill="#c70000"
            stroke="#000000"
            strokeWidth="1"
          />
        );
      })}
    </g>
  );
}

/**
 * XAxis - Time axis (00:00 - 24:00)
 */
function XAxis({ margin, chartWidth, chartHeight }) {
  const hours = [0, 3, 6, 9, 12, 15, 18, 21, 24];
  const xPosition = (hour) => margin.left + (hour / 24) * chartWidth;

  return (
    <g className="x-axis">
      {/* Axis line */}
      <line
        x1={margin.left}
        y1={margin.top + chartHeight}
        x2={margin.left + chartWidth}
        y2={margin.top + chartHeight}
        stroke="#6b7280"
        strokeWidth="1.5"
      />

      {/* Hour labels */}
      {hours.map((hour) => (
        <g key={hour}>
          <line
            x1={xPosition(hour)}
            y1={margin.top + chartHeight}
            x2={xPosition(hour)}
            y2={margin.top + chartHeight + 5}
            stroke="#6b7280"
            strokeWidth="1.5"
          />
          <text
            x={xPosition(hour)}
            y={margin.top + chartHeight + 20}
            textAnchor="middle"
            fill="#9ca3af"
            fontSize="12"
          >
            {String(hour).padStart(2, '0')}:00
          </text>
        </g>
      ))}

      {/* Axis label */}
      <text
        x={margin.left + chartWidth / 2}
        y={margin.top + chartHeight + 35}
        textAnchor="middle"
        fill="#6b7280"
        fontSize="13"
        fontWeight="500"
      >
        Time of Day
      </text>
    </g>
  );
}

/**
 * YAxis - Glucose axis (mg/dL)
 */
function YAxis({ margin, chartHeight, yScale }) {
  const values = [0, 70, 140, 180, 250, 400];

  return (
    <g className="y-axis">
      {/* Axis line */}
      <line
        x1={margin.left}
        y1={margin.top}
        x2={margin.left}
        y2={margin.top + chartHeight}
        stroke="#6b7280"
        strokeWidth="1.5"
      />

      {/* Value labels */}
      {values.map((value) => (
        <g key={value}>
          <line
            x1={margin.left - 5}
            y1={yScale(value)}
            x2={margin.left}
            y2={yScale(value)}
            stroke="#6b7280"
            strokeWidth="1.5"
          />
          <text
            x={margin.left - 10}
            y={yScale(value)}
            textAnchor="end"
            alignmentBaseline="middle"
            fill="#9ca3af"
            fontSize="12"
          >
            {value}
          </text>
        </g>
      ))}

      {/* Axis label */}
      <text
        x={margin.left - 45}
        y={margin.top + chartHeight / 2}
        textAnchor="middle"
        fill="#6b7280"
        fontSize="13"
        fontWeight="500"
        transform={`rotate(-90, ${margin.left - 45}, ${margin.top + chartHeight / 2})`}
      >
        Glucose (mg/dL)
      </text>
    </g>
  );
}

/**
 * ChartLegend - Explanation of AGP elements (positioned overlay style)
 */
function ChartLegend({ hasComparison }) {
  return (
    <div 
      style={{
        position: 'absolute',
        top: '16px',
        right: '16px',
        backgroundColor: 'white',
        border: '1px solid #d1d5db',
        borderRadius: '4px',
        padding: '12px',
        fontSize: '12px',
        lineHeight: '1.8',
        fontFamily: 'monospace',
        boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
        zIndex: 10
      }}
    >
      <LegendItem color="#000000" label="Mediaan" thickness={2} isDashed />
      <LegendItem color="#fb923c" label="Gemiddeld" thickness={2} isDashed />
      <LegendItem color="#3b82f6" label="25-75%" isShaded opacity={0.5} />
      <LegendItem color="#93c5fd" label="5-95%" isShaded opacity={0.5} />
      {hasComparison && <LegendItem color="#9ca3af" label="Vorige periode" thickness={2.5} isDashed />}
      <LegendItem color="#dc2626" label="L2 Hypo (<54)" isCircle markerType="x" />
      <LegendItem color="#f97316" label="L1 Hypo (54-69)" isCircle />
      <LegendItem color="#dc2626" label="Hyper (>250)" isTriangle />
    </div>
  );
}

/**
 * LegendItem - Individual legend entry with visual sample
 */
function LegendItem({ color, label, isDashed, isCircle, isTriangle, markerType, thickness, isShaded, opacity }) {
  return (
    <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '4px' }}>
      {isCircle ? (
        // Circle marker for hypo events
        <div style={{
          width: '14px',
          height: '14px',
          borderRadius: '50%',
          backgroundColor: color,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          flexShrink: 0
        }}>
          {markerType === 'x' && (
            <svg width="10" height="10" viewBox="0 0 10 10">
              <line x1="2" y1="2" x2="8" y2="8" stroke="white" strokeWidth="1.5" />
              <line x1="8" y1="2" x2="2" y2="8" stroke="white" strokeWidth="1.5" />
            </svg>
          )}
        </div>
      ) : isTriangle ? (
        // Triangle marker for hyper events
        <svg width="14" height="14" viewBox="0 0 14 14" style={{ flexShrink: 0 }}>
          <polygon points="7,3 3,11 11,11" fill={color} stroke="white" strokeWidth="1" />
        </svg>
      ) : isShaded ? (
        // Shaded rectangle for percentile bands
        <div style={{
          width: '30px',
          height: '12px',
          backgroundColor: color,
          opacity: opacity || 0.5,
          flexShrink: 0
        }} />
      ) : (
        // Line for median/mean
        <div style={{
          width: '30px',
          height: `${thickness}px`,
          backgroundColor: isDashed ? 'transparent' : color,
          backgroundImage: isDashed 
            ? `repeating-linear-gradient(90deg, ${color} 0, ${color} 4px, transparent 4px, transparent 7px)`
            : 'none',
          flexShrink: 0
        }} />
      )}
      <span style={{ color: '#374151', fontSize: '12px', whiteSpace: 'nowrap' }}>{label}</span>
    </div>
  );
}

┌────────────────────────────────────────────────────────┐
│ FILE: src/components/ComparisonView.jsx
└────────────────────────────────────────────────────────┘

import React from 'react';
import { TrendingUp, TrendingDown, Minus } from 'lucide-react';

/**
 * Safe number formatter - handles NaN, null, undefined, strings
 */
const safeFormat = (val, decimals = 0) => {
  const num = Number(val);
  if (isNaN(num) || !isFinite(num)) return 'N/A';
  return num.toFixed(decimals);
};

/**
 * ComparisonView - Period-over-period comparison component
 * 
 * Grid-based layout: [Label] [Current] [Previous]
 * Inline styles for consistency with MetricsDisplay
 * 
 * @version 2.1.2 CLINICAL GRID
 */
export default function ComparisonView({ 
  currentMetrics, 
  previousMetrics, 
  startDate, 
  endDate,
  prevStart,
  prevEnd
}) {
  if (!currentMetrics || !previousMetrics) {
    return null;
  }

  // Format dates for display
  const formatDate = (date) => {
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    return `${day}-${month}`;
  };

  // Calculate days in each period
  const currentDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
  const previousDays = Math.ceil((prevEnd - prevStart) / (1000 * 60 * 60 * 24)) + 1;

  // Metrics to compare
  const comparisons = [
    {
      id: 'tir',
      label: 'Time in Range',
      sublabel: '70-180 mg/dL',
      current: currentMetrics.tir,
      previous: previousMetrics.tir,
      unit: '%',
      format: (v) => safeFormat(v, 1),
      betterIfHigher: true,
      target: 'Target ≥70%',
    },
    {
      id: 'mean',
      label: 'Mean Glucose',
      current: currentMetrics.mean,
      previous: previousMetrics.mean,
      unit: 'mg/dL',
      format: (v) => safeFormat(v, 0),
      currentSD: currentMetrics.sd,
      previousSD: previousMetrics.sd,
      target: 'Target 70-180',
    },
    {
      id: 'cv',
      label: 'Coefficient Variation',
      current: currentMetrics.cv,
      previous: previousMetrics.cv,
      unit: '%',
      format: (v) => safeFormat(v, 1),
      betterIfLower: true,
      target: 'Target ≤36%',
    },
    {
      id: 'gmi',
      label: 'GMI (est. HbA1c)',
      current: currentMetrics.gmi,
      previous: previousMetrics.gmi,
      unit: '%',
      format: (v) => safeFormat(v, 1),
      betterIfLower: true,
      target: 'Target <7.0%',
    },
  ];

  return (
    <div className="card" style={{ padding: '2rem' }}>
      {/* Header */}
      <div style={{ 
        display: 'flex', 
        justifyContent: 'space-between', 
        alignItems: 'center',
        marginBottom: '1.5rem'
      }}>
        <h3 style={{ 
          fontSize: '1.125rem', 
          fontWeight: 600, 
          color: 'var(--text-primary)'
        }}>
          Period Comparison
        </h3>
        <div style={{ fontSize: '0.875rem', color: 'var(--text-secondary)' }}>
          {formatDate(startDate)} → {formatDate(endDate)} vs {formatDate(prevStart)} → {formatDate(prevEnd)}
        </div>
      </div>

      {/* Comparison Grid */}
      <div style={{ 
        display: 'grid',
        gridTemplateColumns: '200px 1fr 1fr',
        gap: '1rem',
        alignItems: 'stretch'
      }}>
        {comparisons.map((comp) => (
          <ComparisonRow key={comp.id} {...comp} />
        ))}
      </div>
    </div>
  );
}

/**
 * ComparisonRow - Single row in comparison grid
 * [Label] [Current Card] [Previous Card]
 */
function ComparisonRow({ 
  label, 
  sublabel,
  current, 
  previous, 
  unit, 
  format, 
  currentSD,
  previousSD,
  betterIfHigher, 
  betterIfLower,
  target 
}) {
  // Calculate delta and trend
  const delta = current - previous;
  const deltaFormatted = format(Math.abs(delta));
  
  let trendIcon = '→';
  let trendColor = '#6b7280'; // gray-500
  
  if (Math.abs(delta) > 0.5) {
    if (betterIfHigher) {
      trendIcon = delta > 0 ? '↑' : '↓';
      trendColor = delta > 0 ? '#10b981' : '#ef4444'; // green-500 : red-500
    } else if (betterIfLower) {
      trendIcon = delta > 0 ? '↑' : '↓';
      trendColor = delta < 0 ? '#10b981' : '#ef4444'; // green-500 : red-500
    } else {
      trendIcon = delta > 0 ? '↑' : '↓';
    }
  }

  return (
    <>
      {/* Label */}
      <div style={{ 
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        gap: '0.25rem'
      }}>
        <div style={{ 
          fontSize: '0.75rem', 
          fontWeight: 700, 
          letterSpacing: '0.1em', 
          textTransform: 'uppercase',
          color: 'var(--text-secondary)'
        }}>
          {label}
        </div>
        {sublabel && (
          <div style={{ 
            fontSize: '0.625rem', 
            color: '#6b7280',
            textTransform: 'uppercase',
            letterSpacing: '0.05em'
          }}>
            {sublabel}
          </div>
        )}
      </div>

      {/* Current Period Card */}
      <div style={{
        backgroundColor: '#111827',
        color: 'white',
        padding: '1.25rem',
        borderRadius: '4px',
        border: '2px solid #1f2937'
      }}>
        <div style={{ 
          fontSize: '0.6875rem',
          fontWeight: 700,
          letterSpacing: '0.1em',
          textTransform: 'uppercase',
          marginBottom: '0.75rem',
          color: '#9ca3af'
        }}>
          Current Period
        </div>
        <div style={{ 
          fontSize: '2rem',
          fontWeight: 700,
          letterSpacing: '-0.01em',
          color: '#f9fafb',
          fontVariantNumeric: 'tabular-nums',
          lineHeight: 1
        }}>
          {format(current)}
          <span style={{ fontSize: '1rem', marginLeft: '0.25rem', color: '#d1d5db' }}>{unit}</span>
        </div>
        {currentSD != null && (
          <div style={{ 
            fontSize: '1rem',
            fontWeight: 600,
            marginTop: '0.5rem',
            color: '#d1d5db'
          }}>
            ± {safeFormat(currentSD, 0)} SD
          </div>
        )}
        
        {/* Trend Indicator */}
        <div style={{ 
          marginTop: '0.75rem',
          paddingTop: '0.75rem',
          borderTop: '1px solid #374151',
          display: 'flex',
          alignItems: 'center',
          gap: '0.5rem'
        }}>
          <span style={{ fontSize: '1.25rem', color: trendColor }}>{trendIcon}</span>
          <span style={{ fontSize: '0.875rem', color: trendColor, fontWeight: 600 }}>
            {delta > 0 ? '+' : ''}{deltaFormatted} {unit}
          </span>
        </div>
      </div>

      {/* Previous Period Card */}
      <div style={{
        backgroundColor: '#111827',
        color: 'white',
        padding: '1.25rem',
        borderRadius: '4px',
        border: '2px solid #1f2937'
      }}>
        <div style={{ 
          fontSize: '0.6875rem',
          fontWeight: 700,
          letterSpacing: '0.1em',
          textTransform: 'uppercase',
          marginBottom: '0.75rem',
          color: '#9ca3af'
        }}>
          Previous Period
        </div>
        <div style={{ 
          fontSize: '2rem',
          fontWeight: 700,
          letterSpacing: '-0.01em',
          color: '#9ca3af',
          fontVariantNumeric: 'tabular-nums',
          lineHeight: 1
        }}>
          {format(previous)}
          <span style={{ fontSize: '1rem', marginLeft: '0.25rem', color: '#6b7280' }}>{unit}</span>
        </div>
        {previousSD != null && (
          <div style={{ 
            fontSize: '1rem',
            fontWeight: 600,
            marginTop: '0.5rem',
            color: '#9ca3af'
          }}>
            ± {safeFormat(previousSD, 0)} SD
          </div>
        )}
        
        {/* Target Info */}
        {target && (
          <div style={{ 
            marginTop: '0.75rem',
            paddingTop: '0.75rem',
            borderTop: '1px solid #374151',
            fontSize: '0.6875rem',
            color: '#6b7280',
            textTransform: 'uppercase',
            letterSpacing: '0.05em'
          }}>
            {target}
          </div>
        )}
      </div>
    </>
  );
}

┌────────────────────────────────────────────────────────┐
│ FILE: src/components/DayNightSplit.jsx
└────────────────────────────────────────────────────────┘

import React from 'react';

const safeFormat = (val, decimals = 0) => {
  const num = Number(val);
  if (isNaN(num) || !isFinite(num)) return 'N/A';
  return num.toFixed(decimals);
};

export default function DayNightSplit({ dayMetrics, nightMetrics }) {
  if (!dayMetrics || !nightMetrics) return null;

  const comparisons = [
    { id: 'tir', label: 'Time in Range', sublabel: '70-180 mg/dL', day: dayMetrics.tir, night: nightMetrics.tir, unit: '%', format: (v) => safeFormat(v, 1), betterIfHigher: true, showDuration: true },
    { id: 'mean', label: 'Mean Glucose', day: dayMetrics.mean, night: nightMetrics.mean, unit: 'mg/dL', format: (v) => safeFormat(v, 0), daySD: dayMetrics.sd, nightSD: nightMetrics.sd },
    { id: 'cv', label: 'Coefficient Variation', day: dayMetrics.cv, night: nightMetrics.cv, unit: '%', format: (v) => safeFormat(v, 1), betterIfLower: true },
  ];

  return (
    <div className="card" style={{ padding: '2rem' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
        <h3 style={{ fontSize: '1.125rem', fontWeight: 600, color: 'var(--text-primary)' }}>Day/Night Analysis</h3>
        <div style={{ fontSize: '0.875rem', color: 'var(--text-secondary)' }}>06:00-00:00 vs 00:00-06:00</div>
      </div>
      <div style={{ display: 'grid', gridTemplateColumns: '200px 1fr 1fr', gap: '1rem', alignItems: 'stretch' }}>
        {comparisons.map((comp) => (<DayNightRow key={comp.id} {...comp} />))}
      </div>
    </div>
  );
}

function DayNightRow({ label, sublabel, day, night, unit, format, daySD, nightSD, betterIfHigher, betterIfLower, showDuration }) {
  const delta = day - night;
  const deltaFormatted = format(Math.abs(delta));
  let trendIcon = '→', trendColor = '#6b7280';
  if (Math.abs(delta) > 0.5) {
    if (betterIfHigher) { trendIcon = delta > 0 ? '↑' : '↓'; trendColor = delta > 0 ? '#10b981' : '#ef4444'; }
    else if (betterIfLower) { trendIcon = delta > 0 ? '↑' : '↓'; trendColor = delta < 0 ? '#10b981' : '#ef4444'; }
    else { trendIcon = delta > 0 ? '↑' : '↓'; }
  }
  
  return (
    <>
      {/* Label */}
      <div style={{ display: 'flex', flexDirection: 'column', justifyContent: 'center', gap: '0.25rem' }}>
        <div style={{ fontSize: '0.75rem', fontWeight: 700, letterSpacing: '0.1em', textTransform: 'uppercase', color: 'var(--text-secondary)' }}>{label}</div>
        {sublabel && <div style={{ fontSize: '0.625rem', color: '#6b7280', textTransform: 'uppercase', letterSpacing: '0.05em' }}>{sublabel}</div>}
      </div>
      
      {/* Day Card */}
      <div style={{ backgroundColor: '#111827', color: 'white', padding: '1.25rem', borderRadius: '4px', border: '2px solid #1f2937' }}>
        <div style={{ fontSize: '0.6875rem', fontWeight: 700, letterSpacing: '0.1em', textTransform: 'uppercase', marginBottom: '0.75rem', color: '#9ca3af' }}>
          Day (06:00-00:00)
        </div>
        <div style={{ fontSize: '2rem', fontWeight: 700, letterSpacing: '-0.01em', color: '#f9fafb', fontVariantNumeric: 'tabular-nums', lineHeight: 1 }}>
          {format(day)}
          <span style={{ fontSize: '1rem', marginLeft: '0.25rem', color: '#d1d5db' }}>{unit}</span>
        </div>
        {daySD != null && (
          <div style={{ fontSize: '1rem', fontWeight: 600, marginTop: '0.5rem', color: '#d1d5db' }}>
            ± {safeFormat(daySD, 0)} SD
          </div>
        )}
        <div style={{ marginTop: '0.75rem', paddingTop: '0.75rem', borderTop: '1px solid #374151', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
          <span style={{ fontSize: '1.25rem', color: trendColor }}>{trendIcon}</span>
          <span style={{ fontSize: '0.875rem', color: trendColor, fontWeight: 600 }}>
            {delta > 0 ? '+' : ''}{deltaFormatted} {unit} vs night
          </span>
        </div>
      </div>
      
      {/* Night Card */}
      <div style={{ backgroundColor: '#111827', color: 'white', padding: '1.25rem', borderRadius: '4px', border: '2px solid #1f2937' }}>
        <div style={{ fontSize: '0.6875rem', fontWeight: 700, letterSpacing: '0.1em', textTransform: 'uppercase', marginBottom: '0.75rem', color: '#9ca3af' }}>
          Night (00:00-06:00)
        </div>
        <div style={{ fontSize: '2rem', fontWeight: 700, letterSpacing: '-0.01em', color: '#9ca3af', fontVariantNumeric: 'tabular-nums', lineHeight: 1 }}>
          {format(night)}
          <span style={{ fontSize: '1rem', marginLeft: '0.25rem', color: '#6b7280' }}>{unit}</span>
        </div>
        {nightSD != null && (
          <div style={{ fontSize: '1rem', fontWeight: 600, marginTop: '0.5rem', color: '#9ca3af' }}>
            ± {safeFormat(nightSD, 0)} SD
          </div>
        )}
        {showDuration && (
          <div style={{ marginTop: '0.75rem', paddingTop: '0.75rem', borderTop: '1px solid #374151', fontSize: '0.6875rem', color: '#6b7280', textTransform: 'uppercase', letterSpacing: '0.05em' }}>
            6 hours
          </div>
        )}
      </div>
    </>
  );
}

┌────────────────────────────────────────────────────────┐
│ FILE: src/components/WorkdaySplit.jsx
└────────────────────────────────────────────────────────┘

import React from 'react';

const safeFormat = (val, decimals = 0) => {
  const num = Number(val);
  if (isNaN(num) || !isFinite(num)) return 'N/A';
  return num.toFixed(decimals);
};

export default function WorkdaySplit({ workdayMetrics, restdayMetrics }) {
  if (!workdayMetrics || !restdayMetrics) return null;

  const workdayCount = workdayMetrics.days || 0;
  const restdayCount = restdayMetrics.days || 0;

  const comparisons = [
    { id: 'tir', label: 'Time in Range', sublabel: '70-180 mg/dL', workday: workdayMetrics.tir, restday: restdayMetrics.tir, unit: '%', format: (v) => safeFormat(v, 1), betterIfHigher: true },
    { id: 'mean', label: 'Mean Glucose', workday: workdayMetrics.mean, restday: restdayMetrics.mean, unit: 'mg/dL', format: (v) => safeFormat(v, 0), workdaySD: workdayMetrics.sd, restdaySD: restdayMetrics.sd },
    { id: 'cv', label: 'Coefficient Variation', workday: workdayMetrics.cv, restday: restdayMetrics.cv, unit: '%', format: (v) => safeFormat(v, 1), betterIfLower: true },
  ];

  return (
    <div className="card" style={{ padding: '2rem' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
        <h3 style={{ fontSize: '1.125rem', fontWeight: 600, color: 'var(--text-primary)' }}>Work Schedule Analysis</h3>
        <div style={{ fontSize: '0.875rem', color: 'var(--text-secondary)' }}>{workdayCount} workdays vs {restdayCount} rest days</div>
      </div>
      <div style={{ display: 'grid', gridTemplateColumns: '200px 1fr 1fr', gap: '1rem', alignItems: 'stretch' }}>
        {comparisons.map((comp) => (<WorkdayRow key={comp.id} {...comp} />))}
      </div>
    </div>
  );
}

function WorkdayRow({ label, sublabel, workday, restday, unit, format, workdaySD, restdaySD, betterIfHigher, betterIfLower }) {
  const delta = workday - restday;
  const deltaFormatted = format(Math.abs(delta));
  let trendIcon = '→', trendColor = '#6b7280';
  if (Math.abs(delta) > 0.5) {
    if (betterIfHigher) { trendIcon = delta > 0 ? '↑' : '↓'; trendColor = delta > 0 ? '#10b981' : '#ef4444'; }
    else if (betterIfLower) { trendIcon = delta > 0 ? '↑' : '↓'; trendColor = delta < 0 ? '#10b981' : '#ef4444'; }
    else { trendIcon = delta > 0 ? '↑' : '↓'; }
  }
  
  return (
    <>
      {/* Label */}
      <div style={{ display: 'flex', flexDirection: 'column', justifyContent: 'center', gap: '0.25rem' }}>
        <div style={{ fontSize: '0.75rem', fontWeight: 700, letterSpacing: '0.1em', textTransform: 'uppercase', color: 'var(--text-secondary)' }}>{label}</div>
        {sublabel && <div style={{ fontSize: '0.625rem', color: '#6b7280', textTransform: 'uppercase', letterSpacing: '0.05em' }}>{sublabel}</div>}
      </div>
      
      {/* Workday Card */}
      <div style={{ backgroundColor: '#111827', color: 'white', padding: '1.25rem', borderRadius: '4px', border: '2px solid #1f2937' }}>
        <div style={{ fontSize: '0.6875rem', fontWeight: 700, letterSpacing: '0.1em', textTransform: 'uppercase', marginBottom: '0.75rem', color: '#9ca3af' }}>
          Workdays
        </div>
        <div style={{ fontSize: '2rem', fontWeight: 700, letterSpacing: '-0.01em', color: '#f9fafb', fontVariantNumeric: 'tabular-nums', lineHeight: 1 }}>
          {format(workday)}
          <span style={{ fontSize: '1rem', marginLeft: '0.25rem', color: '#d1d5db' }}>{unit}</span>
        </div>
        {workdaySD != null && (
          <div style={{ fontSize: '1rem', fontWeight: 600, marginTop: '0.5rem', color: '#d1d5db' }}>
            ± {safeFormat(workdaySD, 0)} SD
          </div>
        )}
        <div style={{ marginTop: '0.75rem', paddingTop: '0.75rem', borderTop: '1px solid #374151', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
          <span style={{ fontSize: '1.25rem', color: trendColor }}>{trendIcon}</span>
          <span style={{ fontSize: '0.875rem', color: trendColor, fontWeight: 600 }}>
            {delta > 0 ? '+' : ''}{deltaFormatted} {unit} vs rest
          </span>
        </div>
      </div>
      
      {/* Rest Day Card */}
      <div style={{ backgroundColor: '#111827', color: 'white', padding: '1.25rem', borderRadius: '4px', border: '2px solid #1f2937' }}>
        <div style={{ fontSize: '0.6875rem', fontWeight: 700, letterSpacing: '0.1em', textTransform: 'uppercase', marginBottom: '0.75rem', color: '#9ca3af' }}>
          Rest Days
        </div>
        <div style={{ fontSize: '2rem', fontWeight: 700, letterSpacing: '-0.01em', color: '#9ca3af', fontVariantNumeric: 'tabular-nums', lineHeight: 1 }}>
          {format(restday)}
          <span style={{ fontSize: '1rem', marginLeft: '0.25rem', color: '#6b7280' }}>{unit}</span>
        </div>
        {restdaySD != null && (
          <div style={{ fontSize: '1rem', fontWeight: 600, marginTop: '0.5rem', color: '#9ca3af' }}>
            ± {safeFormat(restdaySD, 0)} SD
          </div>
        )}
        <div style={{ marginTop: '0.75rem', paddingTop: '0.75rem', borderTop: '1px solid #374151', fontSize: '0.6875rem', color: '#6b7280', textTransform: 'uppercase', letterSpacing: '0.05em' }}>
          Non-work days
        </div>
      </div>
    </>
  );
}

┌────────────────────────────────────────────────────────┐
│ FILE: src/components/HypoglycemiaEvents.jsx
└────────────────────────────────────────────────────────┘

import React from 'react';
import { AlertTriangle } from 'lucide-react';

/**
 * HypoglycemiaEvents - Warning Panel for Hypo Events
 * 
 * Displays Level 1 and Level 2 hypoglycemia events with urgent visual styling.
 * Positioned under AGP chart as a high-visibility warning section.
 * 
 * @param {Object} props.events - { hypoL1: {count, events}, hypoL2: {count, events} }
 * @param {number} props.tbrPercent - Total time below range percentage
 * 
 * @version 2.1.3 - Added average duration
 */
export default function HypoglycemiaEvents({ events, tbrPercent }) {
  if (!events || (!events.hypoL1?.count && !events.hypoL2?.count)) {
    return null;
  }

  const l1Count = events.hypoL1?.count || 0;
  const l2Count = events.hypoL2?.count || 0;
  const totalEvents = l1Count + l2Count;

  // Calculate average durations
  const l1Events = events.hypoL1?.events || [];
  const l2Events = events.hypoL2?.events || [];
  
  const l1AvgDuration = l1Events.length > 0
    ? Math.round(l1Events.reduce((sum, e) => sum + e.duration, 0) / l1Events.length)
    : 0;
  
  const l2AvgDuration = l2Events.length > 0
    ? Math.round(l2Events.reduce((sum, e) => sum + e.duration, 0) / l2Events.length)
    : 0;
  
  const allEvents = [...l1Events, ...l2Events];
  const avgDuration = allEvents.length > 0
    ? Math.round(allEvents.reduce((sum, e) => sum + e.duration, 0) / allEvents.length)
    : 0;

  return (
    <div 
      style={{
        backgroundColor: '#7f1d1d',
        border: '3px solid #dc2626',
        borderLeft: '8px solid #dc2626',
        padding: '1.5rem',
        marginTop: '1.5rem',
        borderRadius: '4px'
      }}
    >
      <div style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', marginBottom: '1.25rem' }}>
        <AlertTriangle style={{ width: '24px', height: '24px', color: '#fca5a5' }} />
        <h3 style={{ fontSize: '1rem', fontWeight: 700, letterSpacing: '0.1em', textTransform: 'uppercase', color: '#fecaca' }}>
          Hypoglycemia Events
        </h3>
      </div>

      <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(140px, 1fr))', gap: '1rem' }}>
        
        <div style={{ backgroundColor: 'rgba(220, 38, 38, 0.3)', border: '2px solid #dc2626', padding: '1rem', borderRadius: '4px' }}>
          <div style={{ fontSize: '0.75rem', fontWeight: 700, letterSpacing: '0.1em', textTransform: 'uppercase', color: '#fca5a5', marginBottom: '0.5rem' }}>
            Level 2 (&lt;54)
          </div>
          <div style={{ fontSize: '2.5rem', fontWeight: 700, color: '#fee2e2', lineHeight: 1, fontVariantNumeric: 'tabular-nums' }}>
            {l2Count}
          </div>
          <div style={{ fontSize: '0.6875rem', fontWeight: 600, color: '#fca5a5', marginTop: '0.25rem', textTransform: 'uppercase', letterSpacing: '0.05em' }}>
            Critical Events
          </div>
          {l2AvgDuration > 0 && (
            <div style={{ fontSize: '0.875rem', fontWeight: 600, color: '#fed7aa', marginTop: '0.5rem' }}>
              Ø {l2AvgDuration} min
            </div>
          )}
        </div>

        <div style={{ backgroundColor: 'rgba(249, 115, 22, 0.3)', border: '2px solid #f97316', padding: '1rem', borderRadius: '4px' }}>
          <div style={{ fontSize: '0.75rem', fontWeight: 700, letterSpacing: '0.1em', textTransform: 'uppercase', color: '#fed7aa', marginBottom: '0.5rem' }}>
            Level 1 (54-70)
          </div>
          <div style={{ fontSize: '2.5rem', fontWeight: 700, color: '#ffedd5', lineHeight: 1, fontVariantNumeric: 'tabular-nums' }}>
            {l1Count}
          </div>
          <div style={{ fontSize: '0.6875rem', fontWeight: 600, color: '#fed7aa', marginTop: '0.25rem', textTransform: 'uppercase', letterSpacing: '0.05em' }}>
            Warning Events
          </div>
          {l1AvgDuration > 0 && (
            <div style={{ fontSize: '0.875rem', fontWeight: 600, color: '#fde68a', marginTop: '0.5rem' }}>
              Ø {l1AvgDuration} min
            </div>
          )}
        </div>

        <div style={{ backgroundColor: 'rgba(75, 85, 99, 0.4)', border: '2px solid #6b7280', padding: '1rem', borderRadius: '4px' }}>
          <div style={{ fontSize: '0.75rem', fontWeight: 700, letterSpacing: '0.1em', textTransform: 'uppercase', color: '#d1d5db', marginBottom: '0.5rem' }}>
            Time Below Range
          </div>
          <div style={{ fontSize: '2.5rem', fontWeight: 700, color: '#f3f4f6', lineHeight: 1, fontVariantNumeric: 'tabular-nums' }}>
            {tbrPercent != null ? parseFloat(tbrPercent).toFixed(1) : 'N/A'}
            <span style={{ fontSize: '1.25rem', opacity: 0.7 }}>%</span>
          </div>
          <div style={{ fontSize: '0.6875rem', fontWeight: 600, color: '#d1d5db', marginTop: '0.25rem', textTransform: 'uppercase', letterSpacing: '0.05em' }}>
            Target &lt;4%
          </div>
        </div>

        <div style={{ backgroundColor: 'rgba(55, 65, 81, 0.6)', border: '2px solid #4b5563', padding: '1rem', borderRadius: '4px' }}>
          <div style={{ fontSize: '0.75rem', fontWeight: 700, letterSpacing: '0.1em', textTransform: 'uppercase', color: '#e5e7eb', marginBottom: '0.5rem' }}>
            Total Events
          </div>
          <div style={{ fontSize: '2.5rem', fontWeight: 700, color: '#f9fafb', lineHeight: 1, fontVariantNumeric: 'tabular-nums' }}>
            {totalEvents}
          </div>
          <div style={{ fontSize: '0.6875rem', fontWeight: 600, color: '#e5e7eb', marginTop: '0.25rem', textTransform: 'uppercase', letterSpacing: '0.05em' }}>
            L1 + L2 Combined
          </div>
          {avgDuration > 0 && (
            <div style={{ fontSize: '0.875rem', fontWeight: 600, color: '#d1d5db', marginTop: '0.5rem' }}>
              Ø {avgDuration} min
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

┌────────────────────────────────────────────────────────┐
│ FILE: src/components/TIRBar.jsx
└────────────────────────────────────────────────────────┘

import React from 'react';

/**
 * TIRBar - Time in Range Distribution (BRUTALIST)
 * 
 * Displays a horizontal bar chart with Soviet-inspired color palette:
 * - TBR: Red (#c70000) - Warning, critical
 * - TIR: Gray/White - Target achievement
 * - TAR: Yellow (#f4e300) - Caution
 * 
 * Design: Massive borders, no gradients, printed feel
 * 
 * @param {Object} props.metrics - Calculated metrics
 * @version 2.1.1 BRUTALIST
 */
export default function TIRBar({ metrics }) {
  const tbr = parseFloat(metrics.tbr) || 0;
  const tir = parseFloat(metrics.tir) || 0;
  const tar = parseFloat(metrics.tar) || 0;
  
  return (
    <div 
      className="card" 
      style={{ 
        padding: '1.5rem',
        marginBottom: 'clamp(16px, 3vh, 32px)'
      }}
    >
      <h4 style={{
        fontSize: '0.875rem',
        fontWeight: 700,
        letterSpacing: '0.1em',
        textTransform: 'uppercase',
        marginBottom: '1rem',
        color: 'var(--text-primary)'
      }}>
        Time in Range Distribution
      </h4>
      
      {/* Single-line bar - GUARANTEED */}
      <div 
        style={{
          display: 'flex',
          height: '48px',
          width: '100%',
          border: '3px solid var(--border-primary)',
          borderRadius: '0',
          overflow: 'hidden',
          background: 'var(--bg-primary)'
        }}
      >
        {/* TBR - Soviet Red */}
        {tbr > 0 && (
          <div
            style={{
              width: `${tbr}%`,
              background: 'var(--color-tbr)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              color: 'var(--color-white)',
              fontSize: '11px',
              fontWeight: 700,
              letterSpacing: '0.05em',
              flexShrink: 0,
              minWidth: '2px'
            }}
          >
            {tbr > 4 ? `${tbr.toFixed(1)}%` : ''}
          </div>
        )}
        
        {/* TIR - Gray/White */}
        <div
          style={{
            width: `${tir}%`,
            background: 'var(--color-tir)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            color: 'var(--text-primary)',
            fontSize: '12px',
            fontWeight: 700,
            letterSpacing: '0.05em',
            flexShrink: 0,
            minWidth: '2px'
          }}
        >
          {tir.toFixed(1)}%
        </div>
        
        {/* TAR - Yellow */}
        {tar > 0 && (
          <div
            style={{
              width: `${tar}%`,
              background: 'var(--color-tar)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              color: 'var(--color-black)',
              fontSize: '11px',
              fontWeight: 700,
              letterSpacing: '0.05em',
              flexShrink: 0,
              minWidth: '2px'
            }}
          >
            {tar > 4 ? `${tar.toFixed(1)}%` : ''}
          </div>
        )}
      </div>
      
      {/* Legend - Monospace, uppercase */}
      <div 
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          marginTop: '1rem',
          fontSize: '0.75rem',
          fontWeight: 700,
          letterSpacing: '0.05em',
          textTransform: 'uppercase',
          color: 'var(--text-secondary)'
        }}
      >
        <span>TBR &lt;70 mg/dL</span>
        <span>TIR 70-180 mg/dL (Target ≥70%)</span>
        <span>TAR &gt;180 mg/dL</span>
      </div>
    </div>
  );
}

┌────────────────────────────────────────────────────────┐
│ FILE: src/utils/pdfParser.js
└────────────────────────────────────────────────────────┘

/**
 * PDF Parser Utility
 * Extract text from PDF files using pdfjs-dist
 */

import * as pdfjsLib from 'pdfjs-dist';

// Configure PDF.js worker
pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js`;

/**
 * Extract text from a PDF file
 * @param {File} file - PDF file object from input
 * @returns {Promise<string>} Extracted text content
 */
export const extractTextFromPDF = async (file) => {
  try {
    // Read file as ArrayBuffer
    const arrayBuffer = await file.arrayBuffer();
    
    // Load PDF document
    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    
    let fullText = '';
    
    // Extract text from each page
    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
      const page = await pdf.getPage(pageNum);
      const textContent = await page.getTextContent();
      
      // Build text with proper line breaks based on Y position
      let lastY = null;
      const pageLines = [];
      let currentLine = '';
      
      textContent.items.forEach(item => {
        // If Y position changed significantly, it's a new line
        if (lastY !== null && Math.abs(item.transform[5] - lastY) > 5) {
          if (currentLine.trim()) {
            pageLines.push(currentLine.trim());
          }
          currentLine = item.str;
        } else {
          currentLine += ' ' + item.str;
        }
        lastY = item.transform[5];
      });
      
      // Add last line
      if (currentLine.trim()) {
        pageLines.push(currentLine.trim());
      }
      
      fullText += pageLines.join('\n') + '\n';
    }
    
    return fullText;
    
  } catch (err) {
    console.error('PDF parsing error:', err);
    throw new Error(`Failed to extract text from PDF: ${err.message}`);
  }
};

/**
 * Extract text from multiple PDF files and combine
 * @param {File[]} files - Array of PDF file objects
 * @returns {Promise<string>} Combined text from all PDFs
 */
export const extractTextFromMultiplePDFs = async (files) => {
  try {
    const textPromises = files.map(file => extractTextFromPDF(file));
    const texts = await Promise.all(textPromises);
    return texts.join('\n\n--- Next PDF ---\n\n');
  } catch (err) {
    throw new Error(`Failed to process multiple PDFs: ${err.message}`);
  }
};

┌────────────────────────────────────────────────────────┐
│ FILE: src/styles/globals.css
└────────────────────────────────────────────────────────┘

/**
 * AGP+ v2.1 - BRUTALIST GLOBALS
 * 
 * Design Philosophy: NASA Flight Log + 1980s Medical Interface + Brutalist Web
 * 
 * Rules:
 * - No gradients, no shadows (except hover inset)
 * - Massive borders (2-3px black)
 * - Monospace typography
 * - Soviet red + yellow as sparse accents
 * - Cut-on, cut-off transitions (≤100ms, linear)
 * - Printed feel, not floating
 */

@tailwind base;
@tailwind components;
@tailwind utilities;

/* ============================================================================
   CSS VARIABLES - BRUTALIST PALETTE
   ========================================================================= */

:root {
  /* Core Colors - Light Mode */
  --color-black: #000;
  --color-white: #fff;
  --color-gray-dark: #222;
  --color-gray-mid: #666;
  --color-gray-light: #ccc;
  --color-gray-vlight: #eee;
  
  /* Accent Colors - Soviet Inspired */
  --color-red: #c70000;        /* Soviet red - warnings, critical */
  --color-yellow: #f4e300;     /* Data highlight - caution */
  
  /* Glucose Ranges */
  --color-tbr: #c70000;        /* Time Below Range <70 */
  --color-tir: #ddd;           /* Time In Range 70-180 */
  --color-tar: #f4e300;        /* Time Above Range >180 */
  
  /* Base Theme */
  --bg-primary: #fff;
  --bg-secondary: #eee;
  --bg-hero: #000;
  --text-primary: #000;
  --text-secondary: #666;
  --text-inverse: #fff;
  --border-primary: #000;
  --border-secondary: #666;
}

/* Dark Mode */
@media (prefers-color-scheme: dark) {
  :root {
    --bg-primary: #111;
    --bg-secondary: #222;
    --bg-hero: #000;
    --text-primary: #eee;
    --text-secondary: #999;
    --text-inverse: #111;
    --border-primary: #444;
    --border-secondary: #666;
    
    --color-tir: #444;
  }
}

/* ============================================================================
   BASE RESET
   ========================================================================= */

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html {
  font-size: 16px;
  /* NO font smoothing - keep edges sharp */
  -webkit-font-smoothing: none;
  -moz-osx-font-smoothing: grayscale;
}

body {
  font-family: 'SF Mono', 'Consolas', 'Liberation Mono', 'Courier New', monospace;
  line-height: 1.4;
  color: var(--text-primary);
  background: var(--bg-primary);
  font-weight: 400;
}

/* ============================================================================
   TYPOGRAPHY - MONOSPACE HIERARCHY
   ========================================================================= */

h1, h2, h3, h4, h5, h6 {
  font-weight: 700;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  line-height: 1.2;
}

h1 {
  font-size: 2rem;      /* 32px */
  letter-spacing: 0.1em;
}

h2 {
  font-size: 1.5rem;    /* 24px */
  letter-spacing: 0.08em;
}

h3 {
  font-size: 1.25rem;   /* 20px */
}

h4 {
  font-size: 1rem;      /* 16px */
}

/* Metric Values - Large, Monospace */
.metric-value {
  font-size: 3rem;      /* 48px */
  font-weight: 700;
  letter-spacing: -0.02em;
  font-variant-numeric: tabular-nums;
}

/* Labels - Small Caps */
.metric-label {
  font-size: 0.75rem;   /* 12px */
  font-weight: 700;
  letter-spacing: 0.1em;
  text-transform: uppercase;
}

/* ============================================================================
   LAYOUT - ADAPTIVE GRID
   ========================================================================= */

.app-container {
  max-width: 1400px;
  margin: 0 auto;
  padding: clamp(12px, 2vw, 36px);
}

.section {
  margin-bottom: clamp(24px, 4vh, 48px);
}

/* Grid System */
.grid-metrics {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 1rem;
}

@media (max-width: 1024px) {
  .grid-metrics {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 640px) {
  .grid-metrics {
    grid-template-columns: 1fr;
  }
}

/* ============================================================================
   CARDS - MASSIVE BORDERS, NO SHADOWS
   ========================================================================= */

.card {
  background: var(--bg-primary);
  border: 2px solid var(--border-primary);
  border-radius: 2px;
  padding: 1.5rem;
  transition: transform 100ms linear, box-shadow 100ms linear;
}

.card:hover {
  transform: scale(1.03);
  box-shadow: 0 0 0 2px var(--border-primary) inset;
}

/* Hero Card - Black background, white text */
.card-hero {
  background: var(--bg-hero);
  color: var(--text-inverse);
  border: 3px solid var(--border-primary);
  padding: 2rem;
}

/* Secondary Card - Gray background */
.card-secondary {
  background: var(--bg-secondary);
  border: 1px solid var(--border-secondary);
}

/* ============================================================================
   BUTTONS - SHARP, FUNCTIONAL
   ========================================================================= */

.btn {
  font-family: inherit;
  font-size: 0.875rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  padding: 0.75rem 1.5rem;
  border: 2px solid var(--border-primary);
  border-radius: 0;
  background: var(--bg-primary);
  color: var(--text-primary);
  cursor: pointer;
  transition: all 100ms linear;
}

.btn:hover {
  background: var(--text-primary);
  color: var(--bg-primary);
  transform: translateY(-2px);
}

.btn-primary {
  background: var(--color-black);
  color: var(--color-white);
  border-color: var(--color-black);
}

.btn-primary:hover {
  background: var(--color-white);
  color: var(--color-black);
}

.btn-danger {
  background: var(--color-red);
  color: var(--color-white);
  border-color: var(--color-red);
}

/* ============================================================================
   FIXED TOP BANNER
   ========================================================================= */

.top-banner {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 100;
  background: var(--bg-hero);
  color: var(--text-inverse);
  border-bottom: 2px solid var(--border-primary);
  padding: 0.5rem clamp(12px, 2vw, 36px);
  font-size: 0.875rem;
  font-weight: 700;
  letter-spacing: 0.05em;
  text-transform: uppercase;
}

/* ============================================================================
   UTILITY CLASSES
   ========================================================================= */

.text-mono {
  font-family: 'SF Mono', 'Consolas', 'Liberation Mono', 'Courier New', monospace;
  font-variant-numeric: tabular-nums;
}

.border-massive {
  border: 3px solid var(--border-primary);
}

.border-solid {
  border: 2px solid var(--border-primary);
}

.border-thin {
  border: 1px solid var(--border-secondary);
}

.bg-hero {
  background: var(--bg-hero);
  color: var(--text-inverse);
}

.text-red {
  color: var(--color-red);
}

.text-yellow {
  color: var(--color-yellow);
}

.bg-red {
  background: var(--color-red);
}

.bg-yellow {
  background: var(--color-yellow);
}

/* ============================================================================
   BRUTALIST SPACING
   ========================================================================= */

.space-brutal-sm {
  margin-bottom: 1rem;
}

.space-brutal-md {
  margin-bottom: 2rem;
}

.space-brutal-lg {
  margin-bottom: 3rem;
}

/* ============================================================================
   PRINT STYLES (Preserve existing black/white)
   ========================================================================= */

@media print {
  * {
    color: #000 !important;
    background: #fff !important;
    box-shadow: none !important;
  }
  
  .card {
    border: 2px solid #000 !important;
    page-break-inside: avoid;
  }
  
  @page {
    margin: 8mm;
  }
}

┌────────────────────────────────────────────────────────┐
│ FILE: package.json
└────────────────────────────────────────────────────────┘

{
  "name": "agp-plus",
  "version": "2.1.0",
  "description": "AGP+ v2.1 - Ambulatory Glucose Profile Generator for Medtronic 780G CGM data",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0"
  },
  "dependencies": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "lucide-react": "^0.263.1",
    "pdfjs-dist": "^3.11.174"
  },
  "devDependencies": {
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "vite": "^5.4.0"
  },
  "keywords": [
    "diabetes",
    "cgm",
    "ambulatory-glucose-profile",
    "medtronic",
    "780g",
    "glucose-monitoring",
    "healthcare"
  ],
  "author": "Jo Mostert",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/jllmostert/agp-plus-v2.git"
  }
}

┌────────────────────────────────────────────────────────┐
│ FILE: vite.config.js
└────────────────────────────────────────────────────────┘

import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  
  // Development server configuration
  server: {
    port: 3000,
    open: true,
    host: true,
  },
  
  // Build configuration
  build: {
    outDir: 'dist',
    sourcemap: true,
    minify: 'terser',
    
    // Optimize chunk splitting
    rollupOptions: {
      output: {
        manualChunks: {
          'react-vendor': ['react', 'react-dom'],
          'lucide': ['lucide-react'],
        },
      },
    },
    
    // Increase chunk size warning limit for medical data processing
    chunkSizeWarningLimit: 1000,
  },
  
  // Resolve configuration
  resolve: {
    alias: {
      '@': '/src',
      '@core': '/src/core',
      '@components': '/src/components',
      '@hooks': '/src/hooks',
      '@styles': '/src/styles',
    },
  },
});

┌────────────────────────────────────────────────────────┐
│ FILE: index.html
└────────────────────────────────────────────────────────┘

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="AGP+ v2.1 - Ambulatory Glucose Profile Generator for Medtronic 780G CGM data analysis" />
    <meta name="keywords" content="diabetes, CGM, ambulatory glucose profile, medtronic, 780G" />
    <meta name="author" content="Jo Mostert" />
    
    <title>AGP+ v2.1 - Ambulatory Glucose Profile Generator</title>
    
    <!-- Favicon (placeholder - add your own) -->
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    
    <!-- Preload critical resources -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
  </head>
  
  <body>
    <!-- React root element -->
    <div id="root"></div>
    
    <!-- Main application entry point -->
    <script type="module" src="/src/main.jsx"></script>
    
    <!-- Fallback for browsers without JavaScript -->
    <noscript>
      <div style="padding: 2rem; text-align: center; font-family: system-ui;">
        <h1>AGP+ v2.1</h1>
        <p>This application requires JavaScript to run.</p>
        <p>Please enable JavaScript in your browser settings.</p>
      </div>
    </noscript>
  </body>
</html>

┌────────────────────────────────────────────────────────┐
│ FILE: src/main.jsx
└────────────────────────────────────────────────────────┘

import React from 'react';
import { createRoot } from 'react-dom/client';
import AGPGenerator from './components/AGPGenerator.jsx';
import './styles/globals.css';

/**
 * AGP+ v2.1 - Main Application Entry Point
 * 
 * Initializes React 18 root and renders the main AGPGenerator component.
 * Uses the new createRoot API for concurrent features support.
 */

// Get root element
const rootElement = document.getElementById('root');

// Create React 18 root
const root = createRoot(rootElement);

// Render application
root.render(
  <React.StrictMode>
    <AGPGenerator />
  </React.StrictMode>
);

/**
 * DEVELOPMENT NOTES:
 * 
 * - React.StrictMode enables additional development checks
 * - AGPGenerator is the main container component (to be created in PROMPT 7)
 * - globals.css contains dark theme and base styling
 * 
 * For now, AGPGenerator is a placeholder component.
 * It will be implemented after all child components are built (PROMPTS 2-6).
 */

════════════════════════════════════════════════════════
End of Bundle -     5260 lines total
════════════════════════════════════════════════════════
